<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Ëø∑‰Ω†ÁöáÂÆ§Êà∞Áà≠ - ÈÄ£Á∑öÂ∞çÊà∞Áâà</title>
<!-- ÂºïÂÖ• Socket.IO -->
<script src="/socket.io/socket.io.js"></script>
<!-- ÂÇôÁî® CDNÔºåÊñπ‰æøÊú¨Âú∞Ê∏¨Ë©¶ -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<style>
/* --- ÂéüÊúâ CSS Ê®£ÂºèÂÆåÂÖ®‰øùÁïô --- */
:root {
--primary: #3498db;
--accent: #f1c40f;
--danger: #e74c3c;
--dark-bg: #1e272e;
--ui-glass: rgba(30, 39, 46, 0.95);
--font-main: "PingFang TC", "Microsoft JhengHei", "Heiti TC", system-ui, sans-serif;
    --common: #bdc3c7;
    --rare: #f39c12;
    --epic: #9b59b6;
    --legendary: #00cec9;
}

body {
    margin: 0; padding: 0;
    background-color: #000;
    font-family: var(--font-main);
    overflow: hidden;
    width: 100%; height: 100%;
    user-select: none; -webkit-user-select: none;
    touch-action: none;
    position: fixed;
    color: white;
}

#game-container {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex; flex-direction: column;
}

#canvas-wrapper {
    position: relative;
    flex: 1; width: 100%;
    background: #2c3e50;
    overflow: hidden;
    box-shadow: inset 0 -20px 50px rgba(0,0,0,0.5);
}

canvas { display: block; width: 100%; height: 100%; }

/* --- UI Ê®£Âºè --- */
.btn {
    background: linear-gradient(180deg, #3498db, #2980b9);
    border: none; border-radius: 16px;
    padding: 14px 40px;
    color: white; font-size: 20px; font-weight: 800;
    box-shadow: 0 6px 0 #1c5980, 0 10px 10px rgba(0,0,0,0.3);
    cursor: pointer; transition: all 0.1s;
    text-shadow: 0 2px 0 rgba(0,0,0,0.2);
    min-width: 160px; margin: 5px;
    position: relative; overflow: hidden;
}
.btn::after {
    content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    animation: shine 3s infinite;
}
@keyframes shine { 0% { left: -100%; } 20% { left: 100%; } 100% { left: 100%; } }
.btn:active { transform: translateY(4px); box-shadow: 0 0 0 #1c5980; }

.btn-secondary {
    background: linear-gradient(180deg, #95a5a6, #7f8c8d);
    box-shadow: 0 6px 0 #566161, 0 10px 10px rgba(0,0,0,0.3);
    font-size: 16px; padding: 12px 30px;
}
.btn-secondary:active { transform: translateY(4px); box-shadow: 0 0 0 #566161; }

.btn-danger {
    background: linear-gradient(180deg, #e74c3c, #c0392b);
    box-shadow: 0 6px 0 #96281b, 0 10px 10px rgba(0,0,0,0.3);
}

.panel {
    background: var(--ui-glass);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 24px;
    padding: 20px;
    display: flex; flex-direction: column; align-items: center;
    box-shadow: 0 20px 50px rgba(0,0,0,0.6);
}

/* --- Â∫ïÈÉ®Êìç‰ΩúÂçÄ --- */
#ui-layer {
    height: 160px;
    background: var(--ui-glass);
    backdrop-filter: blur(15px);
    border-top: 1px solid rgba(255,255,255,0.15);
    display: flex; flex-direction: column;
    padding: 5px 10px 10px 10px;
    box-sizing: border-box;
    z-index: 20; position: relative;
}

#elixir-area {
    display: flex; align-items: center; gap: 10px;
    margin-bottom: 5px; padding: 0 5px;
    height: 30px;
}
#elixir-badge {
    width: 30px; height: 30px;
    background: linear-gradient(135deg, #a55eea, #8854d0);
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-weight: 900; font-size: 16px;
    box-shadow: 0 0 15px rgba(165, 94, 234, 0.6);
    border: 2px solid #fff; z-index: 2;
}
#elixir-bar-bg {
    flex: 1; height: 12px;
    background: rgba(0,0,0,0.8);
    border-radius: 10px; overflow: hidden; position: relative;
    border: 2px solid #57606f;
}
#elixir-fill {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, #a55eea, #d980fa);
    box-shadow: 0 0 20px #a55eea;
    transition: width 0.1s linear;
}

#deck-area {
    display: flex; align-items: flex-end;
    gap: 8px; height: 100%; flex: 1;
    width: 100%;
}

#next-slot {
    display: flex; flex-direction: column; align-items: center;
    opacity: 0.7; margin-right: 4px;
    background: rgba(0,0,0,0.3); border-radius: 10px; padding: 4px;
    width: 45px; flex-shrink: 0;
}
.slot-label { font-size: 9px; color: #aaa; font-weight: 800; margin-bottom: 2px; }

#hand-cards {
    display: flex; gap: 6px; justify-content: space-between;
    flex: 1; height: 100%;
}

.card {
    flex: 1; max-width: 85px; height: 90%;
    background: linear-gradient(160deg, #3d4c53, #2c3e50);
    border-radius: 10px; position: relative;
    cursor: pointer;
    transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    border: 2px solid #57606f;
    box-shadow: 0 4px 0 rgba(0,0,0,0.3);
    overflow: hidden; user-select: none;
}

.card.common { border-color: var(--common); }
.card.rare { border-color: var(--rare); box-shadow: 0 4px 0 rgba(243, 156, 18, 0.3); }
.card.epic { border-color: var(--epic); box-shadow: 0 4px 0 rgba(155, 89, 182, 0.3); }
.card.legendary { border-color: var(--legendary); box-shadow: 0 4px 0 rgba(0, 206, 201, 0.3); animation: legendPulse 3s infinite; }

@keyframes legendPulse { 0% { box-shadow: 0 0 5px var(--legendary); } 50% { box-shadow: 0 0 15px var(--legendary); } 100% { box-shadow: 0 0 5px var(--legendary); } }

.card-inner {
    width: 100%; height: 100%;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    padding-top: 10px;
    background: radial-gradient(circle at center, rgba(255,255,255,0.1) 0%, transparent 70%);
}
.card:active { transform: scale(0.95); }

/* Dragging State */
.card.dragging { opacity: 0.3; transform: scale(0.9); }

.card.selected {
    transform: translateY(-12px);
    border-width: 3px;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
    background: linear-gradient(160deg, #576574, #3d4c53);
    z-index: 10;
}
.card.disabled {
    filter: grayscale(1) brightness(0.5);
    pointer-events: none; transform: none;
}

.cost {
    position: absolute; top: -1px; left: -1px;
    width: 20px; height: 20px;
    background: #fff; color: #8854d0;
    border-bottom-right-radius: 10px;
    font-weight: 900; font-size: 12px;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    z-index: 2; border: 2px solid #8854d0;
}
.emoji { font-size: 28px; filter: drop-shadow(0 3px 2px rgba(0,0,0,0.3)); margin-bottom: 2px; }
.name { 
    font-size: 10px; font-weight: 700; color: #fff;
    text-shadow: 0 2px 2px rgba(0,0,0,0.8); 
    white-space: nowrap; width: 100%; text-align: center;
    transform: scale(0.9);
}

/* --- HUD --- */
#hud-top {
    position: absolute; top: 0; left: 0; width: 100%;
    padding: 10px 15px; box-sizing: border-box;
    display: flex; justify-content: space-between; align-items: flex-start;
    pointer-events: none; z-index: 15;
}
#timer-box {
    background: rgba(0,0,0,0.6); padding: 5px 15px;
    border-radius: 20px; border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s;
}
#timer-box.double-elixir {
    background: rgba(232, 67, 147, 0.8);
    box-shadow: 0 0 20px #e84393;
    transform: scale(1.1);
}
#timer {
    font-size: 24px; font-weight: 900; color: #fff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8); font-variant-numeric: tabular-nums;
}
/* Èö±ËóèÂñÆÊ©üÁöÑÊö´ÂÅúÔºåÈÄ£Á∑öÁâà‰∏çËÉΩÊö´ÂÅú */
#pause-btn { display: none; }

#emote-wrapper {
    position: absolute; bottom: 170px; left: 15px;
    z-index: 30; display: flex; flex-direction: column-reverse; gap: 10px;
}
#emote-btn {
    width: 44px; height: 44px;
    background: rgba(0,0,0,0.6);
    border: 2px solid #fff; border-radius: 50%;
    font-size: 24px; display: flex; align-items: center; justify-content: center;
    cursor: pointer; pointer-events: auto;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    transition: transform 0.1s;
}
#emote-menu {
    background: rgba(0,0,0,0.8);
    border-radius: 12px; padding: 8px;
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
    opacity: 0; pointer-events: none; transform: scale(0.8) translateY(20px);
    transition: all 0.2s ease-out;
}
#emote-menu.open { opacity: 1; pointer-events: auto; transform: scale(1) translateY(0); }
.emote-opt { font-size: 28px; cursor: pointer; transition: transform 0.1s; }
.emote-opt:hover { transform: scale(1.2); }

#message {
    position: absolute; top: 30%; width: 100%; text-align: center;
    font-size: 48px; font-weight: 900; color: var(--accent);
    -webkit-text-stroke: 2px #000;
    text-shadow: 0 4px 15px rgba(0,0,0,0.6);
    pointer-events: none; opacity: 0; 
    transition: all 0.3s; transform: scale(0.5); z-index: 50;
}
#message.show { opacity: 1; transform: scale(1); }

#elixir-mode-txt {
    position: absolute; top: 20%; width: 100%; text-align: center;
    font-size: 32px; font-weight: 900; color: #e84393;
    text-shadow: 0 0 10px #fff, 0 0 20px #e84393;
    pointer-events: none; opacity: 0; transform: scale(1.5);
    transition: all 0.5s; z-index: 45;
}
#elixir-mode-txt.show { opacity: 1; transform: scale(1); }

.overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); backdrop-filter: blur(8px);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100; transition: opacity 0.3s;
}
.hidden { opacity: 0; pointer-events: none; display: none !important; }

.title-group { text-align: center; margin-bottom: 40px; position: relative; }
h1 {
    font-size: 56px; 
    background: linear-gradient(to bottom, #f1c40f, #e67e22);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    margin: 0; font-style: italic; letter-spacing: -1px;
    transform: skewX(-5deg);
    filter: drop-shadow(0 5px 0 #d35400) drop-shadow(0 15px 10px rgba(0,0,0,0.5));
    font-family: 'Arial Black', var(--font-main); line-height: 1.2;
}
h1::after {
    content: 'üëë'; font-style: normal; position: absolute; top: -25px; right: -10px;
    font-size: 40px; transform: rotate(15deg); -webkit-text-fill-color: initial;
    filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5));
}
.subtitle { font-size: 16px; color: #dfe6e9; letter-spacing: 6px; margin-top: 10px; text-transform: uppercase; opacity: 0.8; }

.menu-group { display: flex; flex-direction: column; gap: 20px; align-items: center; width: 100%; }

/* --- Êñ∞Â¢ûÔºöÂåπÈÖç‰ªãÈù¢Ê®£Âºè --- */
#matchmaking-ui {
    display: flex; flex-direction: column; align-items: center; gap: 10px;
    width: 100%;
}
.match-status {
    color: #bdc3c7; font-size: 18px; margin-bottom: 5px; height: 24px;
}
.spinner {
    width: 40px; height: 40px;
    border: 4px solid rgba(255,255,255,0.1);
    border-left-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
    display: none; /* È†êË®≠Èö±Ëóè */
}
@keyframes spin { 100% { transform: rotate(360deg); } }
.server-input {
    padding: 10px; width: 200px; border-radius: 8px; 
    border: 1px solid #555; background: #333; color: #fff; 
    text-align: center; margin-bottom: 10px;
}

#editor-container { width: 95%; max-width: 550px; max-height: 80vh; }
#editor-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 8px;
    padding: 10px; background: rgba(0,0,0,0.3); border-radius: 16px;
    width: 100%; box-sizing: border-box;
    overflow-y: auto; max-height: 50vh;
}
.editor-card { 
    transform: scale(0.95); opacity: 0.6; transition: all 0.2s; 
    height: auto; aspect-ratio: 3/4; width: 100%;
    position: relative;
}
.editor-card.picked { opacity: 1; transform: scale(1); border-color: #2ecc71; box-shadow: 0 0 15px #2ecc71; }
.editor-card.picked::after {
    content: '‚úì'; position: absolute; bottom: 2px; right: 2px;
    background: #2ecc71; color: #fff; border-radius: 50%;
    width: 16px; height: 16px; font-size: 12px; 
    display: flex; align-items: center; justify-content: center;
}
.editor-desc { min-height: 40px; color: #bdc3c7; font-size: 14px; text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; width: 100%; box-sizing: border-box; margin-top: 10px; }
.menu-btns { display: flex; flex-direction: column; gap: 15px; width: 200px; }
</style>
</head>
<body>
<div id="game-container">
<div id="canvas-wrapper">
<canvas id="gameCanvas"></canvas>

<div id="hud-top">
        <div id="timer-box"><div id="timer">03:00</div></div>
        <!-- ÁßªÈô§ÂñÆÊ©üÊö´ÂÅúÊåâÈàï -->
    </div>
    
    <div id="emote-wrapper">
        <div id="emote-menu">
            <div class="emote-opt" onclick="Game.triggerEmote('üòÇ')">üòÇ</div>
            <div class="emote-opt" onclick="Game.triggerEmote('üò°')">üò°</div>
            <div class="emote-opt" onclick="Game.triggerEmote('üò≠')">üò≠</div>
            <div class="emote-opt" onclick="Game.triggerEmote('üëç')">üëç</div>
        </div>
        <div id="emote-btn" onclick="document.getElementById('emote-menu').classList.toggle('open')">üí¨</div>
    </div>

    <div id="elixir-mode-txt">ÈõôÂÄçËÅñÊ∞¥ÊôÇÂàª!</div>
    <div id="message"></div>
</div>

<!-- Â∫ïÈÉ® UI -->
<div id="ui-layer">
    <div id="elixir-area">
        <div id="elixir-badge">5</div>
        <div id="elixir-bar-bg">
            <div id="elixir-fill"></div>
        </div>
    </div>
    
    <div id="deck-area">
        <div id="next-slot">
            <span class="slot-label">‰∏ãÂºµ</span>
            <div class="card" style="height: 60px; width: 100%; max-width: 50px; cursor: default; pointer-events: none;">
                <div class="card-inner" style="padding-top: 5px;">
                    <div class="emoji" id="next-icon" style="font-size: 20px;">?</div>
                </div>
            </div>
        </div>
        <div id="hand-cards"></div>
    </div>
</div>

<!-- ‰ªãÈù¢Â†ÜÁñä (Start Screen ÊîπÁÇ∫ÈÄ£Á∑öÁâàÊú¨) -->
<div id="start-screen" class="overlay">
    <div class="title-group">
        <h1>CLASH<br>ONLINE</h1>
        <div class="subtitle">Â§ö‰∫∫ÈÄ£Á∑öÂ∞çÊà∞</div>
    </div>
    
    <div id="matchmaking-ui">
        <div class="spinner" id="wait-spinner"></div>
        <div class="match-status" id="match-status-txt">Ê∫ñÂÇôÂ∞±Á∑í</div>
        <!-- Êñπ‰æøÊ∏¨Ë©¶Áî®ÔºåÂØ¶ÈöõÁôºÂ∏ÉÂèØÈö±ËóèÊàñÈ†êË®≠ -->
        <input type="text" id="server-url" class="server-input" placeholder="‰º∫ÊúçÂô® IP (ÁïôÁ©∫Ëá™Âãï)" value="">
    </div>

    <div class="menu-group" id="menu-buttons">
        <button class="btn" onclick="Game.findMatch()">Â∞ãÊâæÂ∞çÊâã</button>
        <button class="btn btn-secondary" onclick="Game.openDeckEditor()">Á∑®ËºØÁâåÁµÑ</button>
    </div>
</div>

<div id="deck-editor" class="overlay hidden">
    <div class="panel" id="editor-container">
        <h2 style="color:var(--accent); margin:0 0 5px 0; font-style:italic;">ÈÖçÁΩÆÂá∫Êà∞ÁâåÁµÑ</h2>
        <div style="color:#aaa; font-size:12px; margin-bottom:10px;">Ë´ãÈÅ∏Êìá 6 ÂºµÂç°Áâå</div>
        <div id="editor-grid"></div>
        <div id="editor-desc" class="editor-desc">ÈªûÊìäÂç°ÁâåÊü•ÁúãË©≥ÊÉÖ</div>
        <button class="btn" style="margin-top:10px;" onclick="Game.closeDeckEditor()">‰øùÂ≠ò‰∏¶ËøîÂõû</button>
    </div>
</div>

<div id="end-screen" class="overlay hidden">
    <h1 id="end-title" style="font-size:80px;">ÂãùÂà©</h1>
    <div style="display:flex; gap:20px;">
        <button class="btn btn-secondary" onclick="location.reload()">ËøîÂõûÂ§ßÂª≥</button>
    </div>
</div>
</div>

<script>
// --- ÈÖçÁΩÆËàáÂ∏∏Êï∏ (ÂÆåÂÖ®‰øùÁïô) ---
const CONFIG = {
ELIXIR_RATE_BASE: 0.018,
ELIXIR_MAX: 10,
GAME_TIME: 180,
DOUBLE_ELIXIR_THRESHOLD: 60,
RIVER_OFFSET: 0.5,
BRIDGE_WIDTH: 60,
COLORS: {
P_MAIN: '#3498db', P_DARK: '#2980b9',
E_MAIN: '#e74c3c', E_DARK: '#c0392b',
GRASS: '#27ae60', WATER: '#48dbfb'
}
};

// --- Âç°ÁâåÂÆöÁæ© (ÂÆåÂÖ®‰øùÁïô) ---
const CARDS = {
knight: {
id: 'knight', name: 'È®éÂ£´', desc: 'ËøëÊà∞Âù¶ÂÖãÔºåÊîªÂÆàÂÖºÂÇô', cost: 3, count: 1,
hp: 1400, dmg: 130, speed: 0.35, range: 0, atkSpd: 65,
type: 'ground', target: 'any', icon: '‚öîÔ∏è', radius: 16, mass: 6.0, deployTime: 60,
rarity: 'common', role: 'mini-tank'
},
archer: {
id: 'archer', name: 'ÂºìÁÆ≠Êâã', desc: 'ÈÅ†Á®ãËº∏Âá∫ÔºåÈõô‰∫∫ÁµÑ', cost: 3, count: 2,
hp: 350, dmg: 80, speed: 0.4, range: 110, atkSpd: 50,
type: 'ground', target: 'any', icon: 'üèπ', radius: 12, mass: 1.5, deployTime: 60,
rarity: 'common', role: 'dps'
},
musketeer: {
id: 'musketeer', name: 'ÁÅ´ÊßçÊâã', desc: 'Ë∂ÖÈÅ†Â∞ÑÁ®ãÔºåÂñÆÈ´îÈ´òÂÇ∑', cost: 4, count: 1,
hp: 600, dmg: 180, speed: 0.35, range: 140, atkSpd: 60,
type: 'ground', target: 'any', icon: 'üëí', radius: 14, mass: 2.0, deployTime: 60,
rarity: 'rare', role: 'dps'
},
giant: {
id: 'giant', name: 'Â∑®‰∫∫', desc: 'Âè™ÊâìÂª∫ÁØâÔºåË∂ÖÂéöËÇâÁõæ', cost: 5, count: 1,
hp: 3500, dmg: 250, speed: 0.2, range: 0, atkSpd: 120,
type: 'ground', target: 'building', icon: 'ü¶ç', radius: 28, mass: 30.0, deployTime: 120,
rarity: 'rare', role: 'tank'
},
prince: {
id: 'prince', name: 'ÁéãÂ≠ê', desc: 'Ë°ùÈãíÈô∑Èô£ÔºåÈõôÂÄçÂÇ∑ÂÆ≥', cost: 5, count: 1,
hp: 1600, dmg: 325, speed: 0.35, range: 0, atkSpd: 80,
type: 'ground', target: 'any', icon: 'üêé', radius: 18, mass: 8.0, deployTime: 60,
chargeSpeed: 0.75, chargeDmgMult: 2.0,
rarity: 'epic', role: 'win-condition'
},
skarmy: {
id: 'skarmy', name: 'È™∑È´èËªçÂúò', desc: '‰∫∫Êµ∑Êà∞Ë°ìÔºåËÑÜÂº±È´òÂÇ∑', cost: 3, count: 5,
hp: 60, dmg: 40, speed: 0.55, range: 0, atkSpd: 30,
type: 'ground', target: 'any', icon: 'üíÄ', radius: 8, mass: 0.5, deployTime: 30,
rarity: 'epic', role: 'swarm'
},
wizard: {
id: 'wizard', name: 'Ê≥ïÂ∏´', desc: 'ÁØÑÂúçÂÇ∑ÂÆ≥ÔºåÊ∏ÖÂÖµÂà©Âô®', cost: 5, count: 1,
hp: 700, dmg: 180, speed: 0.3, range: 120, atkSpd: 90,
type: 'ground', target: 'any', icon: 'üßô‚Äç‚ôÇÔ∏è', aoe: 60, radius: 14, mass: 2.5, deployTime: 60,
rarity: 'rare', role: 'aoe'
},
bats: {
id: 'bats', name: 'ËùôËù†', desc: 'Á©∫‰∏≠Áæ§È´îÔºåÊ•µÈÄüÊîªÊìä', cost: 2, count: 4,
hp: 50, dmg: 50, speed: 0.7, range: 0, atkSpd: 25,
type: 'air', target: 'any', icon: 'ü¶á', radius: 8, mass: 0.5, deployTime: 30,
rarity: 'common', role: 'swarm'
},
minipekka: {
id: 'minipekka', name: 'Ëø∑‰Ω†ÁöÆÂç°', desc: 'ÂñÆÈ´îÁàÜÁôºÔºåÂàáÂù¶Á•ûÂô®', cost: 4, count: 1,
hp: 1100, dmg: 550, speed: 0.55, range: 0, atkSpd: 95,
type: 'ground', target: 'any', icon: 'ü§ñ', radius: 16, mass: 5.0, deployTime: 60,
rarity: 'rare', role: 'tank-killer'
},
hogrider: {
id: 'hogrider', name: 'ÈáéË±¨È®éÂ£´', desc: 'Âø´ÈÄüÁ™ÅÊìäÔºåÁõ¥ÊåáÂª∫ÁØâ', cost: 4, count: 1,
hp: 1400, dmg: 260, speed: 0.8, range: 0, atkSpd: 70,
type: 'ground', target: 'building', icon: 'üê∑', radius: 18, mass: 5.0, deployTime: 60,
rarity: 'rare', role: 'win-condition'
},
babydragon: {
id: 'babydragon', name: 'È£õÈæçÂØ∂ÂØ∂', desc: 'Á©∫‰∏≠ÁØÑÂúçÊîªÊìäÔºåÊúâÈªûËÇâ', cost: 4, count: 1,
hp: 1000, dmg: 130, speed: 0.45, range: 90, atkSpd: 80,
type: 'air', target: 'any', icon: 'üê≤', aoe: 50, radius: 16, mass: 4.0, deployTime: 60,
rarity: 'epic', role: 'aoe'
},
golem: {
id: 'golem', name: 'ÊààÂ¥ôÁü≥‰∫∫', desc: 'Á©∂Ê•µËÇâÁõæÔºåÊ≠ª‰∫°ÁàÜÁÇ∏', cost: 8, count: 1,
hp: 4500, dmg: 280, speed: 0.15, range: 0, atkSpd: 140,
type: 'ground', target: 'building', icon: 'üóø', radius: 32, mass: 50.0, deployTime: 180,
deathDmg: 300,
rarity: 'legendary', role: 'tank'
},
fireball: {
id: 'fireball', name: 'ÁÅ´ÁêÉË°ì', desc: 'ÂçÄÂüüÊ≥ïË°ìÔºåÊìäÈÄÄÊïàÊûú', cost: 4, count: 1,
hp: 0, dmg: 350, speed: 0, range: 0, atkSpd: 0,
type: 'spell', target: 'any', icon: 'üî•', aoe: 110, knockback: 8,
rarity: 'rare', role: 'spell'
},
zap: {
id: 'zap', name: 'ÈõªÊìäÊ≥ïË°ì', desc: '‰ΩéË≤ªÊöàÁú©ÔºåÊâìÊñ∑ÊîªÊìä', cost: 2, count: 1,
hp: 0, dmg: 70, speed: 0, range: 0, atkSpd: 0,
type: 'spell', target: 'any', icon: '‚ö°', aoe: 80, stun: 60,
rarity: 'common', role: 'spell'
},
barrel: {
id: 'barrel', name: 'Âì•Â∏ÉÊûóÈ£õÊ°∂', desc: 'ÂÖ®ÂúñÂÅ∑Ë•≤ÔºåËêΩÂú∞ÁîüÂÖµ', cost: 3, count: 1,
hp: 0, dmg: 50, speed: 0, range: 0, atkSpd: 0,
type: 'spell', target: 'any', icon: 'üõ¢Ô∏è', spawnUnit: 'goblins', knockback: 0,
rarity: 'epic', role: 'win-condition'
},
cannon: {
id: 'cannon', name: 'Âä†Ëæ≤Á†≤', desc: 'Èò≤Á¶¶Âª∫ÁØâÔºåÂ£ΩÂëΩÊúâÈôê', cost: 3, count: 1,
hp: 800, dmg: 100, speed: 0, range: 120, atkSpd: 60,
type: 'building', target: 'any', icon: '‚öôÔ∏è', radius: 20, mass: 100, lifeTime: 1800, deployTime: 180,
rarity: 'common', role: 'building'
},
goblins: {
id: 'goblins', name: 'Âì•Â∏ÉÊûó', cost: 2, count: 3,
hp: 180, dmg: 90, speed: 0.65, range: 0, atkSpd: 35,
type: 'ground', target: 'any', icon: 'üë∫', radius: 10, mass: 0.8, deployTime: 10, rarity: 'common'
}
};
const ALL_CARDS = Object.keys(CARDS).filter(k => k !== 'goblins');

// --- Èü≥ÊïàÁ≥ªÁµ± (ÂÆåÂÖ®‰øùÁïô) ---
const AudioSys = {
ctx: null,
init: function() {
window.AudioContext = window.AudioContext || window.webkitAudioContext;
this.ctx = new AudioContext();
},
play: function(type) {
if(!this.ctx) return;
const t = this.ctx.currentTime;
const osc = this.ctx.createOscillator();
const gain = this.ctx.createGain();

gain.connect(this.ctx.destination);
osc.connect(gain);

if(type === 'spawn') {
osc.frequency.setValueAtTime(300, t);
osc.frequency.exponentialRampToValueAtTime(50, t + 0.2);
gain.gain.setValueAtTime(0.1, t);
gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
osc.start(); osc.stop(t+0.2);
} else if(type === 'attack') {
osc.type = 'triangle';
osc.frequency.setValueAtTime(150, t);
osc.frequency.linearRampToValueAtTime(100, t + 0.05);
gain.gain.setValueAtTime(0.05, t);
gain.gain.linearRampToValueAtTime(0, t + 0.05);
osc.start(); osc.stop(t+0.05);
} else if(type === 'charge_hit') {
osc.type = 'sawtooth';
osc.frequency.setValueAtTime(200, t);
osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
gain.gain.setValueAtTime(0.15, t);
gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
osc.start(); osc.stop(t+0.3);
} else if(type === 'zap') {
osc.type = 'sawtooth';
osc.frequency.setValueAtTime(800, t);
osc.frequency.linearRampToValueAtTime(200, t + 0.15);
gain.gain.setValueAtTime(0.1, t);
gain.gain.linearRampToValueAtTime(0, t + 0.15);
osc.start(); osc.stop(t+0.15);
} else if(type === 'heavy_hit') {
osc.type = 'square';
osc.frequency.setValueAtTime(80, t);
osc.frequency.exponentialRampToValueAtTime(20, t + 0.15);
gain.gain.setValueAtTime(0.2, t);
gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
osc.start(); osc.stop(t+0.15);
} else if(type === 'double_elixir') {
osc.type = 'sine';
osc.frequency.setValueAtTime(440, t);
osc.frequency.linearRampToValueAtTime(880, t + 0.5);
gain.gain.setValueAtTime(0.1, t);
gain.gain.linearRampToValueAtTime(0, t + 0.5);
osc.start(); osc.stop(t+0.5);
} else if(type === 'ui') {
osc.frequency.setValueAtTime(800, t);
gain.gain.setValueAtTime(0.05, t);
gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
osc.start(); osc.stop(t+0.1);
} else if(type === 'boom') {
osc.type = 'sawtooth';
osc.frequency.setValueAtTime(120, t);
osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
gain.gain.setValueAtTime(0.2, t);
gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
osc.start(); osc.stop(t+0.4);
}
}
};

// --- Êï∏Â≠∏Â∑•ÂÖ∑ËàáÁâ©‰ª∂Ê±† (ÂÆåÂÖ®‰øùÁïô) ---
class Vector2 {
constructor(x, y) { this.x = x; this.y = y; }
add(v) { this.x += v.x; this.y += v.y; return this; }
sub(v) { this.x -= v.x; this.y -= v.y; return this; }
mult(n) { this.x *= n; this.y *= n; return this; }
mag() { return Math.sqrt(this.x*this.x + this.y*this.y); }
normalize() { const m = this.mag(); if(m>0) this.mult(1/m); return this; }
dist(v) { return Math.hypot(this.x - v.x, this.y - v.y); }
copy() { return new Vector2(this.x, this.y); }
}

class ParticlePool {
constructor() {
this.pool = [];
this.maxSize = 200;
}
get(x, y, color, type, val) {
let p = this.pool.find(p => !p.active);
if (!p) {
if (this.pool.length < this.maxSize) {
p = new Particle();
this.pool.push(p);
} else {
return null; // Limit reached
}
}
p.reset(x, y, color, type, val);
return p;
}
updateAndDraw(ctx) {
this.pool.forEach(p => {
if (p.active) {
p.update();
p.draw(ctx);
}
});
}
clear() { this.pool.forEach(p => p.active = false); }
}

class Particle {
constructor() { this.active = false; this.pos = new Vector2(0,0); this.vel = new Vector2(0,0); }
reset(x, y, color, type, val) {
this.active = true;
this.pos.x = x; this.pos.y = y;
this.type = type; this.color = color;
this.life = 1.0;

if (type === 'text') {
this.text = val;
this.scale = Math.min(2.0, 0.8 + (val / 200));
this.vel = new Vector2((Math.random()-0.5)*1, -2.5);
this.decay = 0.02;
} else if (type === 'crit') {
this.text = val + "!";
this.scale = 2.5;
this.vel = new Vector2(0, -3);
this.decay = 0.015;
this.color = '#e74c3c';
} else if (type === 'shockwave' || type === 'zap_wave') {
this.vel = new Vector2(0,0);
this.decay = 0.04;
this.size = 10;
this.maxSize = val;
} else if (type === 'soul') {
this.vel = new Vector2(0, -1.5);
this.pos.x += (Math.random()-0.5)*10;
this.decay = 0.03;
this.size = 6;
} else if (type === 'spawn_flash') {
this.vel = new Vector2(0,0);
this.decay = 0.08;
this.size = 10;
} else if (type === 'emote') {
this.text = val;
this.vel = new Vector2(0, -0.8);
this.decay = 0.01;
this.life = 2.5;
} else if (type === 'water_ripple') {
this.vel = new Vector2(0.5, 0);
this.decay = 0.01;
this.size = Math.random()*5 + 2;
} else {
this.vel = new Vector2((Math.random()-0.5)*3, (Math.random()-0.5)*3);
this.decay = 0.05;
this.size = Math.random()*4+2;
}
}
update() {
this.pos.add(this.vel);
this.life -= this.decay;
if(this.life <= 0) this.active = false;
if(this.type === 'shockwave' || this.type === 'zap_wave') this.size += (this.maxSize - this.size) * 0.2;
if(this.type === 'spawn_flash') this.size += 2;
if(this.type === 'soul') this.pos.x += Math.sin(this.pos.y * 0.1) * 0.5;
}
draw(ctx) {
if(!this.active) return;
ctx.globalAlpha = Math.max(0, this.life);

if (this.type === 'text' || this.type === 'crit') {
ctx.save();
ctx.translate(this.pos.x, this.pos.y);
ctx.scale(this.scale, this.scale);
ctx.font = "900 16px sans-serif"; ctx.textAlign = "center";
ctx.fillStyle = this.color; ctx.strokeStyle = '#000'; ctx.lineWidth = 3;
ctx.strokeText(this.text, 0, 0);
ctx.fillText(this.text, 0, 0);
ctx.restore();
} else if (this.type === 'emote') {
const x = this.pos.x, y = this.pos.y;
const w = 40, h = 30;
ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(x - w/2 + 5, y - h - 10); ctx.lineTo(x + w/2 - 5, y - h - 10);
ctx.quadraticCurveTo(x + w/2, y - h - 10, x + w/2, y - h/2 - 10);
ctx.lineTo(x + w/2, y - 10); ctx.quadraticCurveTo(x + w/2, y - 5, x + w/2 - 5, y - 5);
ctx.lineTo(x + 5, y - 5); ctx.lineTo(x, y); ctx.lineTo(x - 5, y - 5);
ctx.lineTo(x - w/2 + 5, y - 5); ctx.quadraticCurveTo(x - w/2, y - 5, x - w/2, y - 10);
ctx.lineTo(x - w/2, y - h/2 - 10); ctx.quadraticCurveTo(x - w/2, y - h - 10, x - w/2 + 5, y - h - 10);
ctx.fill(); ctx.stroke();
ctx.font = "24px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
ctx.fillStyle = 'black'; ctx.fillText(this.text, x, y - h/2 - 8);
} else if (this.type === 'shockwave') {
ctx.strokeStyle = this.color; ctx.lineWidth = 5 * this.life;
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.stroke();
ctx.fillStyle = this.color; ctx.globalAlpha = this.life * 0.3;
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size*0.8, 0, Math.PI*2); ctx.fill();
} else if (this.type === 'zap_wave') {
ctx.strokeStyle = '#00b894'; ctx.lineWidth = 3;
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.stroke();
ctx.fillStyle = '#55efc4'; ctx.globalAlpha = this.life * 0.5;
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.fill();
} else if (this.type === 'spawn_flash') {
ctx.fillStyle = '#fff';
ctx.beginPath(); ctx.moveTo(this.pos.x, this.pos.y - this.size*2);
ctx.lineTo(this.pos.x + 5, this.pos.y); ctx.lineTo(this.pos.x, this.pos.y + this.size*2);
ctx.lineTo(this.pos.x - 5, this.pos.y); ctx.fill();
} else if (this.type === 'soul') {
ctx.fillStyle = '#a29bfe';
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.fill();
} else if (this.type === 'water_ripple') {
ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 1;
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.stroke();
} else {
ctx.fillStyle = this.color;
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2); ctx.fill();
}
ctx.globalAlpha = 1;
}
}

// --- ÈÅäÊà≤ÂØ¶È´îÈ°ûÂà• (Entity, Unit, Tower, Projectile) ÂÆåÂÖ®‰øùÁïô ---
class Entity {
constructor(x, y, team, radius) {
this.pos = new Vector2(x, y);
this.team = team; this.radius = radius;
this.dead = false; this.flash = 0;
this.maxHp = 100; this.hp = 100;
this.knockbackVel = new Vector2(0,0);
this.stunTimer = 0;
this.shakeX = 0; this.shakeY = 0;
}
takeDamage(amt, isCrit = false) {
this.hp -= amt; this.flash = 5;
this.shakeX = (Math.random()-0.5) * 6;
this.shakeY = (Math.random()-0.5) * 6;
const type = isCrit ? 'crit' : 'text';
Game.particles.get(this.pos.x, this.pos.y - 30, isCrit?'#fff':'#fff', type, Math.floor(amt));
if(this.hp <= 0) {
this.dead = true;
if(this.deathDmg) {
Game.projectiles.push(new Projectile(this.pos, new Vector2(0,0), this.deathDmg, 100, 'explosion', this.team));
}
for(let i=0; i<3; i++) Game.particles.get(this.pos.x, this.pos.y, '#a55eea', 'soul', 0);
}
}
applyKnockback(force) {
this.knockbackVel.add(force);
}
applyStun(frames) {
this.stunTimer = Math.max(this.stunTimer, frames);
}
drawShadow(ctx) {
if(this.type === 'air') {
ctx.fillStyle = 'rgba(0,0,0,0.2)';
ctx.beginPath();
ctx.ellipse(this.pos.x, this.pos.y + 40, this.radius, this.radius*0.6, 0, 0, Math.PI*2);
ctx.fill();
} else {
ctx.fillStyle = 'rgba(0,0,0,0.3)';
ctx.beginPath();
ctx.ellipse(this.pos.x, this.pos.y, this.radius, this.radius*0.6, 0, 0, Math.PI*2);
ctx.fill();
}
}
drawHp(ctx, offset) {
if(this.hp < this.maxHp && this.hp > 0) {
const w = 32; const y = this.pos.y - this.radius - offset + this.shakeY;
const x = this.pos.x + this.shakeX;
ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(x - w/2 - 2, y - 2, w + 4, 8);
ctx.fillStyle = this.team === 'player' ? '#3498db' : '#e74c3c';
ctx.fillRect(x - w/2, y, w * Math.max(0, this.hp/this.maxHp), 4);
}
}
drawStatus(ctx) {
if (this.stunTimer > 0) {
ctx.fillStyle = '#f1c40f';
const t = Date.now() * 0.01;
for(let i=0; i<3; i++) {
const a = t + i * (Math.PI*2/3);
const sx = this.pos.x + Math.cos(a) * 12;
const sy = this.pos.y - this.radius - 15 + Math.sin(a) * 5;
ctx.fillText("‚≠ê", sx, sy);
}
}
}
}

class Unit extends Entity {
constructor(x, y, team, key) {
const d = CARDS[key];
super(x, y, team, d.radius);
this.key = key;
this.hp = d.hp; this.maxHp = d.hp;
this.dmg = d.dmg; this.speed = d.speed;
this.range = d.range; this.atkSpd = d.atkSpd;
this.mass = d.mass; this.targetType = d.target;
this.type = d.type || 'ground';
this.aoe = d.aoe || 0;
this.deathDmg = d.deathDmg || 0;

this.chargeSpeed = d.chargeSpeed || 0;
this.chargeDmgMult = d.chargeDmgMult || 1;
this.isCharging = false;
this.moveTime = 0;

this.atkTimer = 0; this.frame = Math.random() * 100;
this.facing = 1; this.state = 'deploy';
this.deployTimer = d.deployTime || 60;
this.maxDeploy = this.deployTimer;
this.lifeTime = d.lifeTime || 0;
this.maxLifeTime = d.lifeTime || 0;
}

update() {
if(this.dead) return;
this.shakeX *= 0.8; this.shakeY *= 0.8;
if(this.knockbackVel.mag() > 0.1) {
this.pos.add(this.knockbackVel);
this.knockbackVel.mult(0.85);
this.collide();
return;
}
if(this.deployTimer > 0) {
this.deployTimer--;
return;
}
if(this.stunTimer > 0) {
this.stunTimer--;
return;
}

this.frame++;
if(this.flash > 0) this.flash--;
if(this.atkTimer > 0) this.atkTimer--;

if(this.type === 'building' && this.lifeTime > 0) {
this.lifeTime--;
this.hp -= this.maxHp / this.maxLifeTime;
if(this.hp <= 0) { this.dead = true; return; }
}

const target = this.findTarget();

if(target) {
const dist = this.pos.dist(target.pos);
const reach = this.range + this.radius + target.radius;

if(dist <= reach) {
this.state = 'attack';
if(this.atkTimer <= 0) this.attack(target);
this.moveTime = 0; this.isCharging = false;
} else if(this.speed > 0) {
this.state = 'move';
this.moveTowards(target.pos);
this.moveTime++;
if(this.chargeSpeed > 0 && this.moveTime > 120) {
this.isCharging = true;
}
}
} else if (this.speed > 0) {
this.state = 'move';
// ÈÄ£Á∑ö‰øÆÊ≠£ÔºöÁ¢∫‰øùÂñÆ‰ΩçÊ∞∏ÈÅ†ÂæÄÂ∞çÈù¢Ëµ∞
// Êú¨Âú∞Áé©ÂÆ∂(Team Player) ÂæÄ‰∏ä(0)ÔºåÂ∞çÊâã(Team Enemy) ÂæÄ‰∏ã(Height)
const goalY = this.team === 'player' ? -100 : Game.height + 100;
this.moveTowards(new Vector2(this.pos.x, goalY));
this.moveTime++;
}

if(this.speed > 0 || this.knockbackVel.mag() > 0.1) this.collide();
}

moveTowards(dest) {
let target = dest.copy();
const riverY = Game.height * CONFIG.RIVER_OFFSET;
const crossRiver = (this.pos.y < riverY && dest.y > riverY) || (this.pos.y > riverY && dest.y < riverY);

if(this.type !== 'air' && crossRiver && Math.abs(this.pos.y - riverY) > 20) {
const bL = Game.width * 0.25, bR = Game.width * 0.75;
const bridgeX = Math.abs(this.pos.x - bL) < Math.abs(this.pos.x - bR) ? bL : bR;
target = new Vector2(bridgeX + (this.pos.x%30 - 15), riverY);
}

let currentSpeed = this.speed;
if(this.isCharging) currentSpeed = this.chargeSpeed;

const dir = target.sub(this.pos).normalize();
this.pos.add(dir.mult(currentSpeed));
if(dir.x > 0.1) this.facing = 1; else if(dir.x < -0.1) this.facing = -1;

if(this.isCharging && this.frame % 4 === 0) {
Game.particles.get(this.pos.x, this.pos.y, '#f1c40f', 'spark', 0);
}
}

collide() {
if(this.type === 'air') return;
const force = new Vector2(0,0);
Game.units.forEach(u => {
if(u === this || u.dead || u.deployTimer > 0 || u.type === 'air') return;
const d = this.pos.dist(u.pos);
const minD = this.radius + u.radius;
if(d < minD) {
const push = this.pos.copy().sub(u.pos).normalize();
const weight = Math.min(2, u.mass / this.mass);
push.mult((minD - d) * 0.15 * weight);
force.add(push);
}
});
this.pos.add(force);
this.pos.x = Math.max(15, Math.min(Game.width-15, this.pos.x));
}

findTarget() {
const list = this.targetType === 'building' ?
[...Game.towers, ...Game.units.filter(u=>u.type==='building')] :
[...Game.towers, ...Game.units];

let best = null, minD = Infinity;
for(let t of list) {
if(t.team !== this.team && !t.dead && t.deployTimer <= 0) {
if(t instanceof Tower && t.isKing && !t.active && t.team !== this.team) continue;

const d = this.pos.dist(t.pos);
if(d < minD) { minD = d; best = t; }
}
}
if(!best && this.targetType !== 'building') {
best = Game.towers.find(t => t.team !== this.team && t.isKing);
}
return best;
}

attack(target) {
const finalDmg = this.isCharging ? this.dmg * this.chargeDmgMult : this.dmg;

if(this.range > 50) {
Game.projectiles.push(new Projectile(this.pos, target, finalDmg, this.aoe, this.key, this.team));
} else {
const isCrit = (this.key === 'minipekka' || this.isCharging);
target.takeDamage(finalDmg, isCrit);
AudioSys.play(this.isCharging ? 'charge_hit' : (isCrit ? 'heavy_hit' : 'attack'));
Game.particles.get((this.pos.x+target.pos.x)/2, (this.pos.y+target.pos.y)/2, '#fff', 'spark', 0);
if(isCrit) Game.shake(8);
}
this.atkTimer = this.atkSpd;
}

draw(ctx) {
ctx.save();
ctx.translate(this.pos.x + this.shakeX, this.pos.y + this.shakeY);
if (this.type === 'air') ctx.translate(0, -40);

if(this.deployTimer > 0) {
ctx.globalAlpha = 0.6;
ctx.fillStyle = 'rgba(0,0,0,0.5)';
ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#ecf0f1';
ctx.beginPath(); ctx.moveTo(0,0);
ctx.arc(0, 0, this.radius + 5, -Math.PI/2, -Math.PI/2 + (Math.PI*2 * (1 - this.deployTimer/this.maxDeploy)));
ctx.lineTo(0,0); ctx.fill();
ctx.restore();
return;
}

if(this.flash > 0) ctx.filter = 'brightness(3)';
const colorMain = this.team === 'player' ? CONFIG.COLORS.P_MAIN : CONFIG.COLORS.E_MAIN;

if (this.key === 'cannon') {
ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-15, -15, 30, 30);
ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();
ctx.fillStyle = colorMain; ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
if(this.lifeTime > 0) {
ctx.fillStyle = '#555'; ctx.fillRect(-15, 20, 30, 4);
ctx.fillStyle = '#fff'; ctx.fillRect(-15, 20, 30 * (this.lifeTime/this.maxLifeTime), 4);
}
const t = this.findTarget();
const angle = t ? Math.atan2(t.pos.y - this.pos.y, t.pos.x - this.pos.x) : -Math.PI/2;
ctx.rotate(angle);
ctx.fillStyle = '#2c3e50'; ctx.fillRect(0,-6,24,12);
} else {
const bob = Math.sin(this.frame * 0.2) * 2;
ctx.translate(0, -bob);
ctx.scale(this.facing, 1);
if (this.key === 'giant') {
ctx.fillStyle = '#d35400'; ctx.fillRect(-14, -28, 28, 28);
ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(0, -34, 12, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = colorMain; ctx.fillRect(-14,-22,28,12);
} else if (this.key === 'golem') {
ctx.fillStyle = '#636e72'; ctx.beginPath(); ctx.arc(0, -15, 22, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#b2bec3'; ctx.beginPath(); ctx.arc(-8, -20, 6, 0, Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.arc(8, -20, 6, 0, Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.arc(0, -10, 8, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#ff7675'; ctx.beginPath(); ctx.arc(0, -15, 3, 0, Math.PI*2); ctx.fill();
} else if (this.key === 'knight') {
ctx.fillStyle = colorMain; ctx.beginPath(); ctx.arc(0, -8, 12, 0, Math.PI*2); ctx.fill();
ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
ctx.save(); ctx.translate(10, -5);
const swing = this.state === 'attack' ? Math.sin(this.frame*0.6)*1.5 : -0.5;
ctx.rotate(swing);
ctx.fillStyle = '#bdc3c7'; ctx.fillRect(0, -12, 4, 24); ctx.fillRect(-3, 8, 10, 3);
ctx.restore();
} else if (this.key === 'archer') {
ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(-8,-5); ctx.lineTo(8,-5); ctx.fill();
ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0, -5, 6, 0, Math.PI*2); ctx.fill();
ctx.strokeStyle = '#8e44ad'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(8, 0, 8, -Math.PI/2, Math.PI/2); ctx.stroke();
} else if (this.key === 'musketeer') {
ctx.fillStyle = '#9b59b6'; ctx.fillRect(-6, -18, 12, 18);
ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0, -20, 8, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#333'; ctx.fillRect(6, -14, 14, 4);
} else if (this.key === 'prince') {
ctx.fillStyle = colorMain; ctx.fillRect(-8, -15, 16, 15);
ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0, -22, 8, 0, Math.PI*2); ctx.fill();
ctx.save(); ctx.translate(8, -10);
const angle = this.state === 'move' ? Math.PI/4 : 0;
ctx.rotate(angle);
ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(25, -2); ctx.lineTo(25, 2); ctx.fill();
if (this.isCharging) { ctx.fillStyle = 'rgba(255,255,255,0.8)'; ctx.fillRect(0,-1,30,2); }
ctx.restore();
} else if (this.key === 'minipekka') {
ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-10,-20,20,20);
ctx.fillStyle = colorMain; ctx.fillRect(-10,-15,20,5);
ctx.fillStyle = '#00ffff'; ctx.shadowBlur=5; ctx.shadowColor='#00ffff';
ctx.beginPath(); ctx.arc(0,-12,4,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-10,-20); ctx.lineTo(-14,-28); ctx.lineTo(-6,-20); ctx.fill(); ctx.beginPath(); ctx.moveTo(10,-20); ctx.lineTo(14,-28); ctx.lineTo(6,-20); ctx.fill();
} else if (this.key === 'hogrider') {
ctx.fillStyle = '#8d6e63'; ctx.beginPath(); ctx.arc(0, -20, 8, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, -20, 8, Math.PI, 0); ctx.fill();
ctx.fillStyle = '#ff7675'; ctx.fillRect(-10, -15, 20, 15);
ctx.fillStyle = '#634200'; ctx.beginPath(); ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI*2); ctx.fill();
ctx.strokeStyle = '#dfe6e9'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(10,-15); ctx.lineTo(10,-25); ctx.stroke();
} else if (this.key === 'babydragon') {
ctx.fillStyle = '#00b894'; ctx.beginPath(); ctx.ellipse(0, 0, 12, 10, 0, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#fdcb6e'; ctx.beginPath(); ctx.moveTo(-5, -5); ctx.lineTo(-15, -15); ctx.lineTo(-5, 5); ctx.fill();
ctx.beginPath(); ctx.moveTo(5, -5); ctx.lineTo(15, -15); ctx.lineTo(5, 5); ctx.fill();
ctx.fillStyle = '#00b894'; ctx.beginPath(); ctx.arc(0, -12, 8, 0, Math.PI*2); ctx.fill();
} else if (this.key === 'bats') {
ctx.fillStyle = '#6c5ce7'; ctx.beginPath(); ctx.arc(0, -5, 6, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#2d3436'; ctx.beginPath(); ctx.moveTo(-5,-5); ctx.lineTo(-12,-12); ctx.lineTo(-5,0); ctx.fill();
ctx.beginPath(); ctx.moveTo(5,-5); ctx.lineTo(12,-12); ctx.lineTo(5,0); ctx.fill();
} else if (this.key === 'goblins') {
ctx.fillStyle = '#55efc4'; ctx.beginPath(); ctx.arc(0,-5,8,0,Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.moveTo(-6,-10); ctx.lineTo(-12,-18); ctx.lineTo(0,-10); ctx.fill();
ctx.beginPath(); ctx.moveTo(6,-10); ctx.lineTo(12,-18); ctx.lineTo(0,-10); ctx.fill();
} else {
ctx.fillStyle = (this.key==='skarmy'?'#fff':colorMain);
ctx.beginPath(); ctx.arc(0, -5, this.radius-2, 0, Math.PI*2); ctx.fill();
}
}
ctx.restore();
this.drawHp(ctx, this.radius + (this.type==='air'?45:5));
this.drawStatus(ctx);
}
}

class Tower extends Entity {
constructor(x, y, team, isKing) {
super(x, y, team, isKing ? 32 : 24);
this.isKing = isKing;
this.active = !isKing;
this.maxHp = isKing ? 4000 : 2500; this.hp = this.maxHp;
this.dmg = isKing ? 120 : 90;
this.range = 160;
this.atkTimer = 0;
this.deployTimer = 0;
}

update() {
if(this.dead) return;
this.shakeX *= 0.8; this.shakeY *= 0.8;
if(this.flash > 0) this.flash--;
if(this.stunTimer > 0) { this.stunTimer--; return; }

if(this.isKing && !this.active) {
if(this.hp < this.maxHp) this.active = true;
else {
const anyPrincessDead = Game.towers.some(t => t.team === this.team && !t.isKing && t.dead);
if(anyPrincessDead) this.active = true;
}
}

if(!this.active) return;
if(this.atkTimer > 0) { this.atkTimer--; return; }

let target = null, minD = this.range;
Game.units.forEach(u => {
if(u.team !== this.team && !u.dead && u.deployTimer <= 0) {
const d = this.pos.dist(u.pos);
if(d < minD) { minD = d; target = u; }
}
});

if(target) {
const spawnY = this.pos.y - (this.isKing ? 40 : 30);
Game.projectiles.push(new Projectile(new Vector2(this.pos.x, spawnY), target, this.dmg, 0, 'arrow', this.team));
this.atkTimer = 45;
}
}

draw(ctx) {
const x = this.pos.x + this.shakeX, y = this.pos.y + this.shakeY;
const teamCol = this.team === 'player' ? CONFIG.COLORS.P_MAIN : CONFIG.COLORS.E_MAIN;

ctx.save();
if(this.flash > 0) ctx.translate((Math.random()-0.5)*4, (Math.random()-0.5)*4);

ctx.fillStyle = '#95a5a6';
const w = this.radius * 1.8;
const h = this.isKing ? 40 : 30;
ctx.fillRect(x - w/2, y - 10, w, 20);

ctx.fillStyle = '#bdc3c7'; ctx.fillRect(x - w/2 + 4, y - 10 - h, w - 8, h);
ctx.fillStyle = teamCol; ctx.fillRect(x - w/2 + 4, y - 10 - h + 5, w - 8, 6);

const topY = y - 10 - h;

if(this.isKing) {
if(this.active) {
ctx.fillStyle = teamCol; ctx.beginPath(); ctx.moveTo(x - w/2 - 2, topY - 6); ctx.lineTo(x + w/2 + 2, topY - 6); ctx.lineTo(x, topY - 30); ctx.fill();
ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(x, topY-30); ctx.lineTo(x, topY-45); ctx.stroke();
} else {
ctx.fillStyle = teamCol; ctx.fillRect(x - 15, topY - 20, 30, 20);
ctx.font = "20px sans-serif"; ctx.textAlign="center"; ctx.fillText("üí§", x, topY - 25 + (Math.sin(Date.now()/300)*5));
}
} else {
ctx.fillStyle = '#bdc3c7'; ctx.beginPath(); ctx.moveTo(x - w/2, topY - 6); ctx.lineTo(x + w/2, topY - 6); ctx.lineTo(x, topY - 20); ctx.fill();
}

ctx.restore();
this.drawHp(ctx, this.isKing ? 65 : 45);
this.drawStatus(ctx);
}
}

class Projectile {
constructor(pos, target, dmg, aoe, type, ownerTeam) {
this.pos = pos.copy();
this.startPos = pos.copy();
this.target = target;
this.dmg = dmg; this.aoe = aoe; this.type = type;
this.ownerTeam = ownerTeam;

this.isSpell = (type === 'fireball' || type === 'barrel' || type === 'zap');
this.dest = this.isSpell ? target.copy() : target.pos.copy();

if(type === 'explosion') {
this.isSpell = true; this.dest = pos.copy(); this.speed = 999;
} else {
const dist = this.pos.dist(this.dest);
if(type === 'barrel') this.speed = Math.max(3, dist / 60);
else if(type === 'fireball') this.speed = 6;
else if(type === 'musketeer') this.speed = 12;
else this.speed = 7;
}

this.totalDist = this.pos.dist(this.dest);
this.height = 0;
this.dead = false;
this.spawnOnHit = CARDS[type]?.spawnUnit || null;
this.knockback = CARDS[type]?.knockback || 0;
this.stun = CARDS[type]?.stun || 0;
this.tail = [];
}

update() {
if(!this.isSpell && !this.target.dead) this.dest = this.target.pos.copy();

const distToTarget = this.pos.dist(this.dest);
const travelled = this.pos.dist(this.startPos);

if (this.isSpell && this.type !== 'zap' && this.type !== 'explosion' || this.type === 'babydragon') {
const progress = travelled / (travelled + distToTarget);
const arcMax = (this.type === 'barrel') ? 200 : 120;
this.height = Math.sin(progress * Math.PI) * arcMax;
}

if(distToTarget < this.speed + 5 && this.height < 15) {
this.hit();
} else {
const dir = this.dest.copy().sub(this.pos).normalize();
this.pos.add(dir.mult(this.speed));
if (this.type !== 'arrow' && this.type !== 'musketeer') {
this.tail.push(new Vector2(this.pos.x, this.pos.y - this.height));
if(this.tail.length > 6) this.tail.shift();
}
}
}

hit() {
this.dead = true;

if (this.spawnOnHit) {
const count = 3;
for(let i=0; i<count; i++) {
const angle = (Math.PI*2 / count) * i;
const sx = this.pos.x + Math.cos(angle)*15;
const sy = this.pos.y + Math.sin(angle)*15;
Game.units.push(new Unit(sx, sy, this.ownerTeam, this.spawnOnHit));
Game.particles.get(sx, sy, '#fff', 'spawn_flash', 0);
}
Game.shake(5);
AudioSys.play('boom');
return;
}

let targets = [];
if(this.isSpell || this.aoe > 0) {
const center = this.isSpell ? this.dest : this.pos;
const r = this.aoe > 0 ? this.aoe : 10;
targets = [...Game.units, ...Game.towers].filter(e => e.pos.dist(center) <= r);

if(this.isSpell || this.type === 'babydragon') {
const pType = (this.type === 'zap') ? 'zap_wave' : 'shockwave';
const pCol = (this.type === 'zap') ? '#55efc4' : '#e74c3c';
Game.particles.get(center.x, center.y, pCol, pType, r);
AudioSys.play(this.type === 'zap' ? 'zap' : 'boom');
}
} else {
if(!this.target.dead) targets = [this.target];
}

targets.forEach(t => {
if(this.ownerTeam && t.team !== this.ownerTeam) {
t.takeDamage(this.dmg);
if(this.knockback > 0 && t instanceof Unit && t.mass < 10) {
const force = t.pos.copy().sub(this.pos).normalize().mult(this.knockback * (2 / t.mass));
t.applyKnockback(force);
}
if(this.stun > 0) t.applyStun(this.stun);
if(t instanceof Tower && t.isKing && t.team !== this.ownerTeam) t.active = true;
}
});

if (this.type !== 'zap') {
const col = (this.type === 'fireball') ? '#e74c3c' : '#f1c40f';
for(let i=0; i<6; i++) Game.particles.get(this.pos.x, this.pos.y, col, 'spark', 0);
}
}

draw(ctx) {
if(this.type === 'zap') return;
ctx.save();
if ((this.isSpell || this.height > 10) && this.type !== 'musketeer') {
ctx.fillStyle = 'rgba(0,0,0,0.3)';
const shadowSize = Math.max(4, 12 * (1 - this.height/250));
ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y, shadowSize, shadowSize*0.6, 0, 0, Math.PI*2); ctx.fill();
}
const drawY = this.pos.y - this.height;
ctx.translate(this.pos.x, drawY);

if(this.type === 'arrow') {
const angle = Math.atan2(this.dest.y - this.pos.y, this.dest.x - this.pos.x);
ctx.rotate(angle);
ctx.fillStyle = '#bdc3c7'; ctx.fillRect(-10, -1, 20, 2);
ctx.fillStyle = '#ecf0f1'; ctx.beginPath(); ctx.moveTo(-10, 0); ctx.lineTo(-15, -3); ctx.lineTo(-15, 3); ctx.fill();
ctx.fillStyle = (this.ownerTeam === 'player' ? '#3498db' : '#e74c3c');
ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(5, -3); ctx.lineTo(5, 3); ctx.fill();
} else {
ctx.fillStyle = (this.type === 'fireball') ? '#e74c3c' : '#f1c40f';
if (this.type === 'barrel') {
ctx.rotate(this.height * 0.1);
ctx.fillStyle = '#d35400'; ctx.fillRect(-6, -8, 12, 16);
ctx.fillStyle = '#f39c12'; ctx.fillRect(-6, -4, 12, 2); ctx.fillRect(-6, 2, 12, 2);
} else if (this.type === 'fireball') {
ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(2, -2, 4, 0, Math.PI*2); ctx.fill();
} else if (this.type === 'musketeer') {
ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fill();
} else {
ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
}
}
ctx.restore();
}
}

// --- ÈÅäÊà≤Ê†∏ÂøÉÈÇèËºØ (‰øÆÊîπÁÇ∫ÈÄ£Á∑öÁâà) ---
let socket; // ÂÖ®Â±Ä Socket

const Game = {
canvas: null, ctx: null,
width: 0, height: 0,
frame: 0, running: false, paused: false,
units: [], towers: [], projectiles: [],
particles: new ParticlePool(),
elixir: 5, 
// ÁßªÈô§ enemyElixirÔºåÂõ†ÁÇ∫Áî±Â∞çÊâãËá™Ë°åË®àÁÆó
doubleElixirMode: false,

userLoadout: ['knight', 'archer', 'giant', 'fireball', 'musketeer', 'bats'],
deck: [], hand: [], nextCard: null,

selectedIdx: null,
draggingIdx: null,
dragPos: {x: 0, y: 0},
isDragging: false,

shakeTimer: 0, timerInt: null, timeLeft: 0,
roomID: null, // Êñ∞Â¢ûÊàøÈñì ID

init: function() {
    this.canvas = document.getElementById('gameCanvas');
    this.ctx = this.canvas.getContext('2d');

    const gameContainer = document.getElementById('game-container');
    gameContainer.addEventListener('pointerdown', e => this.handlePointerDown(e));
    gameContainer.addEventListener('pointermove', e => this.handlePointerMove(e));
    gameContainer.addEventListener('pointerup', e => this.handlePointerUp(e));

    window.addEventListener('resize', () => this.resize());
    this.resize();
    AudioSys.init();
    this.renderElixir();
},

resize: function() {
    const wrap = document.getElementById('canvas-wrapper');
    this.width = wrap.clientWidth;
    this.height = wrap.clientHeight;
    this.canvas.width = this.width;
    this.canvas.height = this.height;
},

// --- ÈÄ£Á∑öÁõ∏ÈóúÊñπÊ≥ï ---
findMatch: function() {
    const urlInput = document.getElementById('server-url').value;
    // Âè™ÊúâÁ¨¨‰∏ÄÊ¨°ÊàñÊõ¥Êîπ URL ÊôÇÊâçÂàùÂßãÂåñ socket
    if(!socket || (urlInput && socket.io.uri !== urlInput)) {
        if(socket) socket.disconnect();
        // Â¶ÇÊûúËº∏ÂÖ•Ê°ÜÊúâÂÄºÂ∞±Áî®Ëº∏ÂÖ•Ê°ÜÔºåÂê¶ÂâáËá™Âãï(ÈÉ®ÁΩ≤ÊôÇÁî®)
        socket = urlInput ? io(urlInput) : io(); 
        this.setupSocketEvents();
    } else {
        if(!socket.connected) socket.connect();
    }

    socket.emit('find_match');
    
    // Êõ¥Êñ∞ UI ÁãÄÊÖã
    document.getElementById('matchmaking-ui').style.display = 'flex';
    document.getElementById('menu-buttons').style.display = 'none';
    document.getElementById('wait-spinner').style.display = 'block';
    document.getElementById('match-status-txt').innerText = "Ê≠£Âú®Â∞ãÊâæÂ∞çÊâã...";
    
    // Ê®°Êì¨È†êË®àÊôÇÈñì
    let waitTime = 0;
    if(this.waitInt) clearInterval(this.waitInt);
    this.waitInt = setInterval(() => {
        waitTime++;
        document.getElementById('match-status-txt').innerText = `Ê≠£Âú®Â∞ãÊâæÂ∞çÊâã... (${waitTime}s)`;
    }, 1000);
},

setupSocketEvents: function() {
    socket.on('connect', () => console.log("Â∑≤ÈÄ£Á∑öËá≥‰º∫ÊúçÂô®"));
    
    socket.on('waiting', (msg) => {
        // ‰øùÊåÅÁ≠âÂæÖ UI
    });

    socket.on('game_start', (data) => {
        clearInterval(this.waitInt);
        this.roomID = data.roomID;
        console.log("ÈÅäÊà≤ÈñãÂßãÔºÅÊàøÈñì:", this.roomID);
        document.getElementById('match-status-txt').innerText = "ÈÖçÂ∞çÊàêÂäüÔºÅ";
        setTimeout(() => this.startOnlineGame(), 500);
    });

    socket.on('remote_action', (data) => {
        if(data.type === 'spawn') {
            // ÈóúÈçµÔºöÊé•Êî∂Â∞çÊâã‰∏ãÂÖµÔºåÂ∫ßÊ®ôÁøªËΩâ
            const realX = this.width - data.x;
            const realY = this.height - data.y;
            this.spawn(data.card, realX, realY, 'enemy');
        } else if(data.type === 'emote') {
            this.showEmote(data.val, 'enemy');
        }
    });
    
    socket.on('opponent_left', () => {
        this.msg("Â∞çÊâãÂ∑≤Èõ¢Èñã");
        this.endGame(true); // Â∞çÊâãÈõ¢ÈñãÂà§Ë¥è
    });
},

startOnlineGame: function() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('end-screen').classList.add('hidden');
    
    // ÈáçÁΩÆ UI
    document.getElementById('matchmaking-ui').style.display = 'none'; // Èö±ËóèÂåπÈÖçUIÔºå‰∏ãÊ¨°È°ØÁ§∫
    document.getElementById('wait-spinner').style.display = 'none';
    document.getElementById('menu-buttons').style.display = 'flex'; // ÊÅ¢Âæ©ÊåâÈàïÁµ¶‰∏ãÊ¨°Áî®
    
    this.reset();
    this.running = true;
    this.paused = false;
    this.loop();

    this.timeLeft = CONFIG.GAME_TIME;
    this.doubleElixirMode = false;
    this.updateTimerDisplay();

    if(this.timerInt) clearInterval(this.timerInt);
    this.timerInt = setInterval(() => {
        if(!this.running) return;
        this.timeLeft--;
        this.updateTimerDisplay();

        if(this.timeLeft === CONFIG.DOUBLE_ELIXIR_THRESHOLD) {
            this.doubleElixirMode = true;
            const msg = document.getElementById('elixir-mode-txt');
            msg.className = 'show';
            document.getElementById('timer-box').classList.add('double-elixir');
            AudioSys.play('double_elixir');
            setTimeout(() => msg.className = '', 2000);
        }

        if(this.timeLeft <= 0) this.endGame(null);
    }, 1000);
},

updateTimerDisplay: function() {
    const m = Math.floor(this.timeLeft/60);
    const s = this.timeLeft%60;
    const el = document.getElementById('timer');
    el.innerText = `0${m}:${s<10?'0'+s:s}`;
    if(this.timeLeft <= 10) el.style.color = (this.timeLeft%2===0) ? '#e74c3c' : '#fff';
    else el.style.color = '#fff';
},

// ÊîπÁÇ∫ÈÄ£Á∑öÁâàÔºö‰∏çÂÖÅË®±Êö´ÂÅú
pauseGame: function() {},
resumeGame: function() {},
quitGame: function() { 
    if(socket) socket.disconnect();
    this.running = false; 
    clearInterval(this.timerInt); 
    this.showStartScreen(); 
},

showStartScreen: function() { 
    document.getElementById('start-screen').classList.remove('hidden'); 
    document.getElementById('end-screen').classList.add('hidden'); 
    // ÊÅ¢Âæ©ÈñãÂßãÁï´Èù¢ÂàùÂßãÁãÄÊÖã
    document.getElementById('matchmaking-ui').style.display = 'block';
    document.getElementById('wait-spinner').style.display = 'none';
    document.getElementById('match-status-txt').innerText = "Ê∫ñÂÇôÂ∞±Á∑í";
    document.getElementById('menu-buttons').style.display = 'flex';
    document.getElementById('server-url').style.display = 'block'; // ËÆìÁî®Êà∂ÂèØ‰ª•Êîπ IP
},

reset: function() {
    this.units = []; this.towers = []; this.projectiles = [];
    this.particles.clear();
    this.elixir = 5; // Âè™ÈúÄË¶ÅÁÆ°Ëá™Â∑±ÁöÑÊ∞¥
    this.frame = 0;
    document.getElementById('timer-box').classList.remove('double-elixir');

    this.deck = [...this.userLoadout, ...this.userLoadout].sort(() => Math.random()-0.5);
    this.hand = [];
    for(let i=0; i<4; i++) this.hand.push(this.drawCardFromDeck());
    this.nextCard = this.drawCardFromDeck();
    this.selectedIdx = null;

    this.renderDeck();

    const pY = this.height - 140;
    const eY = 140; // Â∞çÊâãÁöÑÂ°îÂú®‰∏äÈù¢
    const bL = this.width*0.25, bR = this.width*0.75;

    this.towers = [
        new Tower(bL, pY, 'player', false), new Tower(bR, pY, 'player', false), new Tower(this.width/2, pY+50, 'player', true),
        new Tower(bL, eY, 'enemy', false), new Tower(bR, eY, 'enemy', false), new Tower(this.width/2, eY-50, 'enemy', true)
    ];
},

triggerEmote: function(emoji) {
    const king = this.towers.find(t => t.team === 'player' && t.isKing);
    if(king) {
        Game.particles.get(king.pos.x, king.pos.y - 60, null, 'emote', emoji);
        document.getElementById('emote-menu').classList.remove('open');
        // ÁôºÈÄÅÁµ¶Â∞çÊâã
        if(socket) socket.emit('action', { roomID: this.roomID, type: 'emote', val: emoji });
    }
},
// È°ØÁ§∫Â∞çÊâãË°®ÊÉÖ
showEmote: function(emoji, team) {
    const king = this.towers.find(t => t.team === team && t.isKing);
    if(king) {
        Game.particles.get(king.pos.x, king.pos.y - 60, null, 'emote', emoji);
    }
},

openDeckEditor: function() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('deck-editor').classList.remove('hidden');
    this.renderDeckEditor();
},
closeDeckEditor: function() {
    if(this.userLoadout.length !== 6) { alert("Ë´ãÂøÖÈ†àÈÅ∏Êìá 6 ÂºµÂç°ÁâåÔºÅ"); return; }
    document.getElementById('deck-editor').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
},
toggleEditorCard: function(key) {
    const idx = this.userLoadout.indexOf(key);
    if(idx > -1) this.userLoadout.splice(idx, 1);
    else if(this.userLoadout.length < 6) this.userLoadout.push(key);
    const d = CARDS[key];
    document.getElementById('editor-desc').innerText = `${d.name}: ${d.desc}`;
    this.renderDeckEditor();
},
renderDeckEditor: function() {
    const grid = document.getElementById('editor-grid');
    grid.innerHTML = '';
    ALL_CARDS.forEach(key => {
    const d = CARDS[key];
    const isPicked = this.userLoadout.includes(key);
    const el = document.createElement('div');
    el.className = `card editor-card ${isPicked ? 'picked' : ''} ${d.rarity || 'common'}`;
    el.innerHTML = `<div class="cost">${d.cost}</div><div class="card-inner"><div class="emoji">${d.icon}</div></div>`;
    el.onclick = () => this.toggleEditorCard(key);
    grid.appendChild(el);
    });
},

drawCardFromDeck: function() {
    if(this.deck.length === 0) this.deck = [...this.userLoadout, ...this.userLoadout].sort(()=>Math.random()-0.5);
    let card = this.deck.pop();
    const sameInHand = this.hand.filter(c => c === card).length;
    if (sameInHand >= 2 && this.deck.length > 0) {
    this.deck.unshift(card);
    card = this.deck.pop();
    }
    return card;
},

renderElixir: function() {
    const pct = (this.elixir / CONFIG.ELIXIR_MAX) * 100;
    document.getElementById('elixir-fill').style.width = pct + '%';
    document.getElementById('elixir-badge').innerText = Math.floor(this.elixir);

    const cards = document.querySelectorAll('#hand-cards .card');
    cards.forEach((el, i) => {
    if (this.hand[i]) {
    const cost = CARDS[this.hand[i]].cost;
    if(this.elixir < cost) el.classList.add('disabled');
    else el.classList.remove('disabled');
    }
    });
},

renderDeck: function() {
    document.getElementById('next-icon').innerText = CARDS[this.nextCard].icon;
    const container = document.getElementById('hand-cards');
    container.innerHTML = '';

    this.hand.forEach((key, i) => {
    const d = CARDS[key];
    const el = document.createElement('div');
    el.className = `card ${d.rarity || 'common'}`;
    el.dataset.index = i; 

    if(this.selectedIdx === i && !this.isDragging) el.classList.add('selected');
    if(this.draggingIdx === i) el.classList.add('dragging');

    el.innerHTML = `
    <div class="cost">${d.cost}</div>
    <div class="card-inner">
    <div class="emoji">${d.icon}</div>
    <div class="name">${d.name}</div>
    </div>
    `;
    container.appendChild(el);
    });
    this.renderElixir();
},

handlePointerDown: function(e) {
    if(!this.running || this.paused) return;
    const target = e.target.closest('.card');
    if(target && target.dataset.index !== undefined && !target.classList.contains('disabled')) {
        const idx = parseInt(target.dataset.index);
        if(document.getElementById('deck-editor').classList.contains('hidden') === false) return;
        if(target.classList.contains('editor-card') || target.closest('#next-slot')) return;

        this.draggingIdx = idx;
        this.isDragging = true;
        this.selectedIdx = idx;
        AudioSys.play('ui');

        const rect = this.canvas.getBoundingClientRect();
        this.dragPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        this.renderDeck();
    } else {
        if (this.selectedIdx !== null && !this.isDragging) {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if(y < this.height) this.trySpawn(this.selectedIdx, x, y);
        }
    }
},

handlePointerMove: function(e) {
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (this.isDragging) { this.dragPos = { x: x, y: y }; }
    this.hoverPos = { x: x, y: y };
},

handlePointerUp: function(e) {
    if (this.isDragging) {
        const rect = this.canvas.getBoundingClientRect();
        const y = e.clientY - rect.top;
        if (y < this.height && y > 0) {
            this.trySpawn(this.draggingIdx, this.dragPos.x, this.dragPos.y);
        } else {
            this.selectedIdx = null;
        }
        this.isDragging = false;
        this.draggingIdx = null;
        this.renderDeck();
    }
},

trySpawn: function(idx, x, y) {
    const key = this.hand[idx];
    const cardDef = CARDS[key];

    if (this.checkValidSpawn(cardDef.type, y, x) && this.elixir >= cardDef.cost) {
        this.elixir -= cardDef.cost;
        
        // 1. Êú¨Âú∞È°ØÁ§∫
        this.spawn(key, x, y, 'player');
        
        // 2. ÂÇ≥ÈÄÅÁµ¶‰º∫ÊúçÂô®
        if(socket) {
            socket.emit('action', {
                roomID: this.roomID,
                type: 'spawn',
                card: key,
                x: x, // ÂÇ≥ÈÄÅËá™Â∑±ÁöÑÂ∫ßÊ®ô
                y: y
            });
        }

        this.hand[idx] = this.nextCard;
        this.nextCard = this.drawCardFromDeck();
        this.selectedIdx = null;
        this.renderDeck();
        return true;
    } else {
        if(this.elixir >= cardDef.cost) this.msg("ÁÑ°Ê≥ïÊîæÁΩÆÊñºÊ≠§ÂçÄÂüü");
        else this.msg("ËÅñÊ∞¥‰∏çË∂≥!");
        return false;
    }
},

checkValidSpawn: function(type, y, x) {
    if (type === 'spell') return true;
    const riverY = this.height * CONFIG.RIVER_OFFSET;
    if (y > riverY) return true;

    const enemyLeftTower = this.towers.find(t => t.team === 'enemy' && t.pos.x < this.width/2 && !t.isKing);
    const enemyRightTower = this.towers.find(t => t.team === 'enemy' && t.pos.x > this.width/2 && !t.isKing);
    if (!enemyLeftTower && x < this.width/2 && y > 150) return true;
    if (!enemyRightTower && x > this.width/2 && y > 150) return true;

    return false;
},

spawn: function(key, x, y, team) {
    const d = CARDS[key];
    AudioSys.play('spawn');

    if(d.type === 'spell') {
        const originY = team === 'player' ? this.height : 0;
        Game.projectiles.push(new Projectile(new Vector2(this.width/2, originY), new Vector2(x, y), d.dmg, d.aoe, key, team));
    } else {
        Game.particles.get(x, y, '#fff', 'spawn_flash', 0);
        const form = d.count === 1 ? [{x:0,y:0}] :
        d.count === 2 ? [{x:-15,y:0}, {x:15,y:0}] :
        d.count === 3 ? [{x:0,y:-10}, {x:-15,y:10}, {x:15,y:10}] :
        d.count === 4 ? [{x:-10,y:-10}, {x:10,y:-10}, {x:-10,y:10}, {x:10,y:10}] :
        [{x:0,y:0}, {x:-15,y:-15}, {x:15,y:-15}, {x:-15,y:15}, {x:15,y:15}];

        form.forEach((off, i) => {
            if(i < d.count) {
                // Â¶ÇÊûúÊòØ enemyÔºåÊúÉËá™ÂãïËµ∞‰∏ã‰æÜÔºõplayer Ëµ∞‰∏äÂéª (Áî± Unit update Ê±∫ÂÆö)
                this.units.push(new Unit(x+off.x, y+off.y, team, key));
            }
        });
    }
},

msg: function(txt) {
    const el = document.getElementById('message');
    el.innerText = txt; el.className = 'show';
    setTimeout(() => el.className = '', 1200);
},

shake: function(amount) { this.shakeTimer = amount; },

loop: function() {
    if(!this.running) return;
    requestAnimationFrame(() => this.loop());
    if(this.paused) return;

    this.frame++;

    const rateMult = this.doubleElixirMode ? 2 : 1;
    this.elixir = Math.min(CONFIG.ELIXIR_MAX, this.elixir + CONFIG.ELIXIR_RATE_BASE * rateMult);
    this.renderElixir();

    // --- ÁßªÈô§ AI ÈÇèËºØÔºåÂõ†ÁÇ∫Â∞çÊâãÊòØÁúü‰∫∫ ---
    // ÂéüÊúâÁöÑ AI loop Â∑≤Âà™Èô§
    // ...

    [...this.units, ...this.towers, ...this.projectiles].forEach(e => e.update());
    this.particles.updateAndDraw(this.ctx); 

    this.units = this.units.filter(u => !u.dead);
    this.towers = this.towers.filter(t => !t.dead);
    this.projectiles = this.projectiles.filter(p => !p.dead);

    const pK = this.towers.find(t=>t.team==='player'&&t.isKing);
    const eK = this.towers.find(t=>t.team==='enemy'&&t.isKing);
    if(!pK) this.endGame(false);
    else if(!eK) this.endGame(true);

    this.draw();
},

draw: function() {
    const ctx = this.ctx;
    ctx.clearRect(0, 0, this.width, this.height);

    ctx.save();
    if(this.shakeTimer > 0) {
    ctx.translate((Math.random()-0.5)*this.shakeTimer, (Math.random()-0.5)*this.shakeTimer);
    this.shakeTimer *= 0.9;
    }

    this.drawMap(ctx);

    this.units.forEach(u => u.drawShadow(ctx));
    this.towers.forEach(t => t.drawShadow(ctx));

    const entities = [...this.towers, ...this.units].sort((a,b) => a.pos.y - b.pos.y);
    entities.forEach(e => e.draw(ctx));

    this.projectiles.forEach(p => p.draw(ctx));
    this.particles.updateAndDraw(ctx);

    if(this.isDragging && this.draggingIdx !== null) {
        const key = this.hand[this.draggingIdx];
        const d = CARDS[key];
        const valid = this.checkValidSpawn(d.type, this.dragPos.y, this.dragPos.x);

        ctx.save();
        ctx.translate(this.dragPos.x, this.dragPos.y);

        const r = d.aoe || d.range || d.radius;
        if(d.type === 'spell') {
            ctx.fillStyle = valid ? 'rgba(52, 152, 219, 0.2)' : 'rgba(231, 76, 60, 0.2)';
            ctx.beginPath(); ctx.arc(0, 0, d.aoe || 50, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = valid ? '#3498db' : '#e74c3c'; ctx.lineWidth = 2; ctx.stroke();
        } else {
            ctx.fillStyle = valid ? 'rgba(255, 255, 255, 0.3)' : 'rgba(231, 76, 60, 0.3)';
            ctx.beginPath(); ctx.arc(0, 0, d.radius, 0, Math.PI*2); ctx.fill();
            if (d.range > 0) {
                ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.setLineDash([5,5]);
                ctx.beginPath(); ctx.arc(0, 0, d.range, 0, Math.PI*2); ctx.stroke();
            }
        }
        ctx.font = "40px sans-serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.globalAlpha = 0.7;
        ctx.fillText(d.icon, 0, 0);
        ctx.restore();
    }
    else if(this.selectedIdx !== null && this.hoverPos && !this.paused && !this.isDragging) {
        const d = CARDS[this.hand[this.selectedIdx]];
        const valid = this.checkValidSpawn(d.type, this.hoverPos.y, this.hoverPos.x);
        ctx.save();
        ctx.translate(this.hoverPos.x, this.hoverPos.y);
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = valid ? '#3498db' : '#e74c3c';
        ctx.beginPath(); ctx.arc(0, 0, d.aoe || d.radius, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
    ctx.restore();
},

drawMap: function(ctx) {
    if (this.doubleElixirMode) {
    ctx.fillStyle = '#6c5ce7';
    ctx.fillRect(0, 0, this.width, this.height);
    ctx.globalAlpha = 0.2;
    }
    ctx.fillStyle = CONFIG.COLORS.GRASS; ctx.fillRect(0, 0, this.width, this.height);
    ctx.globalAlpha = 1.0;

    ctx.fillStyle = 'rgba(0,0,0,0.03)'; const size = 40;
    for(let x=0; x<this.width; x+=size) for(let y=0; y<this.height; y+=size) if((x/size + y/size)%2===0) ctx.fillRect(x, y, size, size);

    const ry = this.height * CONFIG.RIVER_OFFSET;
    ctx.fillStyle = CONFIG.COLORS.WATER;
    ctx.fillRect(0, ry-30, this.width, 60);

    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    const t = this.frame * 2;
    for(let y=ry-25; y<ry+25; y+=8) {
    const shift = Math.sin(y*0.1 + t*0.02) * 10;
    ctx.fillRect(0, y, this.width, 2);
    }

    if (this.frame % 10 === 0) {
    const rx = Math.random() * this.width;
    const ry_p = ry - 20 + Math.random() * 40;
    Game.particles.get(rx, ry_p, null, 'water_ripple', 0);
    }

    const drawBridge = (bx) => {
    ctx.fillStyle = '#636e72'; ctx.fillRect(bx-CONFIG.BRIDGE_WIDTH/2, ry-35, CONFIG.BRIDGE_WIDTH, 70);
    ctx.fillStyle = '#b2bec3'; ctx.fillRect(bx-CONFIG.BRIDGE_WIDTH/2+4, ry-35, CONFIG.BRIDGE_WIDTH-8, 70);
    ctx.fillStyle = '#dfe6e9'; for(let i=0; i<6; i++) ctx.fillRect(bx-CONFIG.BRIDGE_WIDTH/2+6, ry-30 + i*11, CONFIG.BRIDGE_WIDTH-12, 4);
    ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(bx-CONFIG.BRIDGE_WIDTH/2+4, ry+35, CONFIG.BRIDGE_WIDTH-8, 5);
    };
    drawBridge(this.width*0.25); drawBridge(this.width*0.75);
},

endGame: function(win) {
    this.running = false;
    clearInterval(this.timerInt);
    if(win===null) {
    const pHp = this.towers.filter(t=>t.team==='player').reduce((a,b)=>a+b.hp,0);
    const eHp = this.towers.filter(t=>t.team==='enemy').reduce((a,b)=>a+b.hp,0);
    win = pHp >= eHp;
    }
    document.getElementById('end-screen').classList.remove('hidden');
    const title = document.getElementById('end-title');
    title.innerText = win ? "ÂãùÂà©!" : "Â§±Êïó";
    title.style.color = win ? "#f1c40f" : "#e74c3c";
    
    // Êñ∑Á∑ö
    if(socket) socket.disconnect();
}
};

window.onload = () => Game.init();

</script>
</body>
</html>