<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Ëø∑‰Ω†ÁöáÂÆ§Êà∞Áà≠ - Á∂ìÂÖ∏ÈÄ£Á∑öÁâà</title>
<script src="/socket.io/socket.io.js"></script>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

<style>
/* --- 1. ÂéüÂßãÈÖçËâ≤ËàáËÆäÊï∏ÈÇÑÂéü --- */
:root {
    --primary: #3498db;
    --accent: #f1c40f;
    --danger: #e74c3c;
    --dark-bg: #1e272e;
    --ui-glass: rgba(30, 39, 46, 0.95); /* ÂéüÂßãÊ∑±Ëâ≤ÁéªÁíÉ */
    --font-main: "PingFang TC", "Microsoft JhengHei", "Heiti TC", system-ui, sans-serif;
    /* Rarity Colors */
    --common: #bdc3c7;
    --rare: #f39c12;
    --epic: #9b59b6;
    --legendary: #00cec9;
}

body {
    margin: 0; padding: 0;
    background-color: #000;
    font-family: var(--font-main);
    overflow: hidden;
    width: 100%; height: 100%;
    user-select: none; -webkit-user-select: none;
    touch-action: none;
    position: fixed;
    color: white;
}

#game-container {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex; flex-direction: column;
}

#canvas-wrapper {
    position: relative;
    flex: 1; width: 100%;
    background: #2c3e50; /* ÂéüÂßãËÉåÊôØËâ≤ */
    overflow: hidden;
    box-shadow: inset 0 -20px 50px rgba(0,0,0,0.5);
}

canvas { display: block; width: 100%; height: 100%; }

/* --- UI Ê®£Âºè (ÈÇÑÂéüÂéüÂßãÊåâÈàïËàáÈù¢Êùø) --- */
.btn {
    background: linear-gradient(180deg, #3498db, #2980b9);
    border: none; border-radius: 16px;
    padding: 14px 40px;
    color: white; font-size: 20px; font-weight: 800;
    box-shadow: 0 6px 0 #1c5980, 0 10px 10px rgba(0,0,0,0.3);
    cursor: pointer; transition: all 0.1s;
    text-shadow: 0 2px 0 rgba(0,0,0,0.2);
    min-width: 160px; margin: 5px;
    position: relative; overflow: hidden;
}
.btn::after {
    content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    animation: shine 3s infinite;
}
@keyframes shine { 0% { left: -100%; } 20% { left: 100%; } 100% { left: 100%; } }
.btn:active { transform: translateY(4px); box-shadow: 0 0 0 #1c5980; }

.btn-secondary {
    background: linear-gradient(180deg, #95a5a6, #7f8c8d);
    box-shadow: 0 6px 0 #566161, 0 10px 10px rgba(0,0,0,0.3);
    font-size: 16px; padding: 12px 30px;
}
.btn-secondary:active { transform: translateY(4px); box-shadow: 0 0 0 #566161; }

.panel {
    background: var(--ui-glass);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 24px;
    padding: 20px;
    display: flex; flex-direction: column; align-items: center;
    box-shadow: 0 20px 50px rgba(0,0,0,0.6);
}

/* --- Â∫ïÈÉ®Êìç‰ΩúÂçÄ (ÈÇÑÂéüÂéüÂßã‰ΩàÂ±Ä) --- */
#ui-layer {
    height: 160px;
    background: var(--ui-glass);
    backdrop-filter: blur(15px);
    border-top: 1px solid rgba(255,255,255,0.15);
    display: flex; flex-direction: column;
    padding: 5px 10px 10px 10px;
    box-sizing: border-box;
    z-index: 20; position: relative;
}

#elixir-area {
    display: flex; align-items: center; gap: 10px;
    margin-bottom: 5px; padding: 0 5px;
    height: 30px;
}
#elixir-badge {
    width: 30px; height: 30px;
    background: linear-gradient(135deg, #a55eea, #8854d0);
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-weight: 900; font-size: 16px;
    box-shadow: 0 0 15px rgba(165, 94, 234, 0.6);
    border: 2px solid #fff; z-index: 2;
}
#elixir-bar-bg {
    flex: 1; height: 12px;
    background: rgba(0,0,0,0.8);
    border-radius: 10px; overflow: hidden; position: relative;
    border: 2px solid #57606f;
}
#elixir-fill {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, #a55eea, #d980fa);
    box-shadow: 0 0 20px #a55eea;
    transition: width 0.1s linear;
}

#deck-area {
    display: flex; align-items: flex-end;
    gap: 8px; height: 100%; flex: 1;
    width: 100%;
}

#next-slot {
    display: flex; flex-direction: column; align-items: center;
    opacity: 0.7; margin-right: 4px;
    background: rgba(0,0,0,0.3); border-radius: 10px; padding: 4px;
    width: 45px; flex-shrink: 0;
}
.slot-label { font-size: 9px; color: #aaa; font-weight: 800; margin-bottom: 2px; }

#hand-cards {
    display: flex; gap: 6px; justify-content: space-between;
    flex: 1; height: 100%;
}

.card {
    flex: 1; max-width: 85px; height: 90%;
    background: linear-gradient(160deg, #3d4c53, #2c3e50);
    border-radius: 10px; position: relative;
    cursor: pointer;
    transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    border: 2px solid #57606f;
    box-shadow: 0 4px 0 rgba(0,0,0,0.3);
    overflow: hidden; user-select: none;
}

.card.common { border-color: var(--common); }
.card.rare { border-color: var(--rare); box-shadow: 0 4px 0 rgba(243, 156, 18, 0.3); }
.card.epic { border-color: var(--epic); box-shadow: 0 4px 0 rgba(155, 89, 182, 0.3); }
.card.legendary { border-color: var(--legendary); box-shadow: 0 4px 0 rgba(0, 206, 201, 0.3); animation: legendPulse 3s infinite; }

@keyframes legendPulse { 0% { box-shadow: 0 0 5px var(--legendary); } 50% { box-shadow: 0 0 15px var(--legendary); } 100% { box-shadow: 0 0 5px var(--legendary); } }

.card-inner {
    width: 100%; height: 100%;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    padding-top: 10px;
    background: radial-gradient(circle at center, rgba(255,255,255,0.1) 0%, transparent 70%);
}
.card:active { transform: scale(0.95); }
.card.dragging { opacity: 0.3; transform: scale(0.9); }
.card.selected {
    transform: translateY(-12px);
    border-width: 3px;
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
    background: linear-gradient(160deg, #576574, #3d4c53);
    z-index: 10;
}
.card.disabled {
    filter: grayscale(1) brightness(0.5);
    pointer-events: none; transform: none;
}
.cost {
    position: absolute; top: -1px; left: -1px;
    width: 20px; height: 20px;
    background: #fff; color: #8854d0;
    border-bottom-right-radius: 10px;
    font-weight: 900; font-size: 12px;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    z-index: 2; border: 2px solid #8854d0;
}
.emoji { font-size: 28px; filter: drop-shadow(0 3px 2px rgba(0,0,0,0.3)); margin-bottom: 2px; }
.name { 
    font-size: 10px; font-weight: 700; color: #fff;
    text-shadow: 0 2px 2px rgba(0,0,0,0.8); 
    white-space: nowrap; width: 100%; text-align: center;
    transform: scale(0.9);
}

/* --- Top HUD & Name Display --- */
#hud-top {
    position: absolute; top: 0; left: 0; width: 100%;
    padding: 10px 15px; box-sizing: border-box;
    display: flex; justify-content: space-between; align-items: flex-start;
    pointer-events: none; z-index: 15;
}
#timer-box {
    background: rgba(0,0,0,0.6); padding: 5px 15px;
    border-radius: 20px; border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.3s; margin: 0 auto; pointer-events: none;
}
#timer-box.double-elixir {
    background: rgba(232, 67, 147, 0.8);
    box-shadow: 0 0 20px #e84393;
    transform: scale(1.1);
}
#timer {
    font-size: 24px; font-weight: 900; color: #fff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8); font-variant-numeric: tabular-nums;
}

/* Êñ∞Â¢ûÔºöÂ∑¶‰∏äËßíÂ∞çÊâãÂêçÂ≠ó */
#enemy-info {
    position: absolute; top: 15px; left: 15px;
    background: rgba(231, 76, 60, 0.8); padding: 6px 14px;
    border-radius: 12px; border: 2px solid #fff;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    color: white; font-weight: bold; font-size: 16px;
    text-shadow: 0 2px 2px rgba(0,0,0,0.5);
    pointer-events: auto;
    display: flex; align-items: center; gap: 5px;
}

/* Emotes */
#emote-wrapper {
    position: absolute; bottom: 170px; left: 15px;
    z-index: 30; display: flex; flex-direction: column-reverse; gap: 10px;
}
#emote-btn {
    width: 44px; height: 44px;
    background: rgba(0,0,0,0.6);
    border: 2px solid #fff; border-radius: 50%;
    font-size: 24px; display: flex; align-items: center; justify-content: center;
    cursor: pointer; pointer-events: auto;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    transition: transform 0.1s;
}
#emote-menu {
    background: rgba(0,0,0,0.8);
    border-radius: 12px; padding: 8px;
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px;
    opacity: 0; pointer-events: none; transform: scale(0.8) translateY(20px);
    transition: all 0.2s ease-out;
}
#emote-menu.open { opacity: 1; pointer-events: auto; transform: scale(1) translateY(0); }
.emote-opt { font-size: 28px; cursor: pointer; transition: transform 0.1s; }
.emote-opt:hover { transform: scale(1.2); }

#message {
    position: absolute; top: 30%; width: 100%; text-align: center;
    font-size: 48px; font-weight: 900; color: var(--accent);
    -webkit-text-stroke: 2px #000;
    text-shadow: 0 4px 15px rgba(0,0,0,0.6);
    pointer-events: none; opacity: 0; 
    transition: all 0.3s; transform: scale(0.5); z-index: 50;
}
#message.show { opacity: 1; transform: scale(1); }

#elixir-mode-txt {
    position: absolute; top: 20%; width: 100%; text-align: center;
    font-size: 32px; font-weight: 900; color: #e84393;
    text-shadow: 0 0 10px #fff, 0 0 20px #e84393;
    pointer-events: none; opacity: 0; transform: scale(1.5);
    transition: all 0.5s; z-index: 45;
}
#elixir-mode-txt.show { opacity: 1; transform: scale(1); }

.overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); backdrop-filter: blur(8px);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100; transition: opacity 0.3s;
}
.hidden { opacity: 0; pointer-events: none; display: none !important; }

.title-group { text-align: center; margin-bottom: 40px; position: relative; }
h1 {
    font-size: 56px; 
    background: linear-gradient(to bottom, #f1c40f, #e67e22);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    margin: 0; font-style: italic; letter-spacing: -1px;
    transform: skewX(-5deg);
    filter: drop-shadow(0 5px 0 #d35400) drop-shadow(0 15px 10px rgba(0,0,0,0.5));
    font-family: 'Arial Black', var(--font-main); line-height: 1.2;
}
h1::after {
    content: 'üëë'; font-style: normal; position: absolute; top: -25px; right: -10px;
    font-size: 40px; transform: rotate(15deg); -webkit-text-fill-color: initial;
    filter: drop-shadow(0 5px 5px rgba(0,0,0,0.5));
}
.subtitle { font-size: 16px; color: #dfe6e9; letter-spacing: 6px; margin-top: 10px; text-transform: uppercase; opacity: 0.8; }

.menu-group { display: flex; flex-direction: column; gap: 20px; align-items: center; width: 100%; }

/* Matchmaking Styles */
#matchmaking-ui {
    display: flex; flex-direction: column; align-items: center; gap: 15px; width: 100%;
}
.input-box {
    padding: 12px; font-size: 18px; border-radius: 10px; border: none;
    text-align: center; width: 220px;
    background: rgba(255,255,255,0.1); color: #fff;
    border: 1px solid rgba(255,255,255,0.3);
}
.match-status { color: #bdc3c7; font-size: 16px; height: 24px; display: flex; align-items: center; gap: 10px; }
.spinner {
    width: 20px; height: 20px;
    border: 3px solid rgba(255,255,255,0.1);
    border-left-color: var(--accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none;
}
@keyframes spin { 100% { transform: rotate(360deg); } }

/* Editor Styles */
#editor-container { width: 95%; max-width: 550px; max-height: 80vh; }
#editor-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 8px;
    padding: 10px; background: rgba(0,0,0,0.3); border-radius: 16px;
    width: 100%; box-sizing: border-box;
    overflow-y: auto; max-height: 50vh;
}
.editor-card { 
    transform: scale(0.95); opacity: 0.6; transition: all 0.2s; 
    height: auto; aspect-ratio: 3/4; width: 100%;
    position: relative;
}
.editor-card.picked { opacity: 1; transform: scale(1); border-color: #2ecc71; box-shadow: 0 0 15px #2ecc71; }
.editor-card.picked::after {
    content: '‚úì'; position: absolute; bottom: 2px; right: 2px;
    background: #2ecc71; color: #fff; border-radius: 50%;
    width: 16px; height: 16px; font-size: 12px; 
    display: flex; align-items: center; justify-content: center;
}
.rec-tag { position: absolute; top: -5px; right: -5px; background: #2ecc71; color: #fff; font-size: 10px; padding: 2px 5px; border-radius: 4px; font-weight: bold; z-index: 5; box-shadow: 0 2px 2px rgba(0,0,0,0.5); }
.editor-desc { min-height: 40px; color: #bdc3c7; font-size: 14px; text-align: center; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px; width: 100%; box-sizing: border-box; margin-top: 10px; }

</style>
</head>
<body>
<div id="game-container">
    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>

        <div id="hud-top">
            <!-- Â∑¶‰∏äËßíÔºöÂ∞çÊâãÂêçÂ≠ó (ÈÇÑÂéüÂæåÊñ∞Â¢û) -->
            <div id="enemy-info">
                <span style="font-size:20px;">‚öîÔ∏è</span>
                <span id="enemy-name-txt">Á≠âÂæÖÂ∞çÊâã...</span>
            </div>
            <div id="timer-box"><div id="timer">03:00</div></div>
        </div>
        
        <div id="emote-wrapper">
            <div id="emote-menu">
                <div class="emote-opt" onclick="Game.triggerEmote('üòÇ')">üòÇ</div>
                <div class="emote-opt" onclick="Game.triggerEmote('üò°')">üò°</div>
                <div class="emote-opt" onclick="Game.triggerEmote('üò≠')">üò≠</div>
                <div class="emote-opt" onclick="Game.triggerEmote('üëç')">üëç</div>
            </div>
            <div id="emote-btn" onclick="document.getElementById('emote-menu').classList.toggle('open')">üí¨</div>
        </div>

        <div id="elixir-mode-txt">ÈõôÂÄçËÅñÊ∞¥ÊôÇÂàª!</div>
        <div id="message"></div>
    </div>

    <!-- Â∫ïÈÉ® UI (ÈÇÑÂéü) -->
    <div id="ui-layer">
        <div id="elixir-area">
            <div id="elixir-badge">5</div>
            <div id="elixir-bar-bg">
                <div id="elixir-fill"></div>
            </div>
        </div>
        
        <div id="deck-area">
            <div id="next-slot">
                <span class="slot-label">‰∏ãÂºµ</span>
                <div class="card" style="height: 60px; width: 100%; max-width: 50px; cursor: default; pointer-events: none;">
                    <div class="card-inner" style="padding-top: 5px;">
                        <div class="emoji" id="next-icon" style="font-size: 20px;">?</div>
                    </div>
                </div>
            </div>
            <div id="hand-cards"></div>
        </div>
    </div>

    <!-- Start Screen (ÈÇÑÂéüÈ¢®Ê†º + Êñ∞Â¢ûÊö±Á®±) -->
    <div id="start-screen" class="overlay">
        <div class="title-group">
            <h1>CLASH<br>ONLINE</h1>
            <div class="subtitle">Á∂ìÂÖ∏ÈÄ£Á∑öÁâà</div>
        </div>
        
        <div id="matchmaking-ui">
            <input type="text" id="nickname" class="input-box" placeholder="Ëº∏ÂÖ•‰Ω†ÁöÑÊö±Á®±" maxlength="8" value="Áé©ÂÆ∂1">
            
            <div class="match-status">
                <div class="spinner" id="wait-spinner"></div>
                <div id="match-status-txt">Ê∫ñÂÇôÂ∞±Á∑í</div>
            </div>

            <button class="btn" id="find-btn" onclick="Game.findMatch()">Â∞ãÊâæÂ∞çÊâã</button>
            <button class="btn btn-secondary" onclick="Game.openDeckEditor()">Á∑®ËºØÁâåÁµÑ</button>
        </div>
    </div>

    <!-- Editor (ÂäüËÉΩ‰øùÁïô) -->
    <div id="deck-editor" class="overlay hidden">
        <div class="panel" id="editor-container">
            <h2 style="color:var(--accent); margin:0 0 5px 0; font-style:italic;">ÈÖçÁΩÆÂá∫Êà∞ÁâåÁµÑ</h2>
            <div style="color:#aaa; font-size:12px; margin-bottom:10px;">Ë´ãÈÅ∏Êìá 6 ÂºµÂç°Áâå</div>
            <div id="editor-grid"></div>
            <div id="editor-desc" class="editor-desc">ÈªûÊìäÂç°ÁâåÊü•ÁúãË©≥ÊÉÖ</div>
            <button class="btn" style="margin-top:10px;" onclick="Game.closeDeckEditor()">‰øùÂ≠ò‰∏¶ËøîÂõû</button>
        </div>
    </div>

    <div id="end-screen" class="overlay hidden">
        <h1 id="end-title" style="font-size:80px;">ÂãùÂà©</h1>
        <div style="display:flex; gap:20px;">
            <button class="btn" onclick="location.reload()">ËøîÂõûÂ§ßÂª≥</button>
        </div>
    </div>
</div>

<script>
// --- ÈÖçÁΩÆ (ÈÇÑÂéüÂéüÊú¨ÁöÑËçâÂú∞ËàáÊ∞¥Ëâ≤) ---
const CONFIG = {
    ELIXIR_RATE_BASE: 0.018, ELIXIR_MAX: 10, GAME_TIME: 180, DOUBLE_ELIXIR_THRESHOLD: 60,
    RIVER_OFFSET: 0.5, BRIDGE_WIDTH: 60,
    COLORS: { P_MAIN: '#3498db', E_MAIN: '#e74c3c', GRASS: '#27ae60', WATER: '#48dbfb' } // ÈÇÑÂéü
};

// --- Âç°ÁâåÂÆöÁæ© (‰øùÁïôÊâÄÊúâÊïòËø∞ËàáÊï∏ÂÄº) ---
const CARDS = {
    knight: { id: 'knight', name: 'È®éÂ£´', desc: 'ËøëÊà∞Âù¶ÂÖãÔºåÊîªÂÆàÂÖºÂÇô', cost: 3, count: 1, hp: 1400, dmg: 130, speed: 0.35, range: 0, atkSpd: 65, type: 'ground', target: 'any', icon: '‚öîÔ∏è', radius: 16, mass: 6.0, deployTime: 60, rarity: 'common' },
    archer: { id: 'archer', name: 'ÂºìÁÆ≠Êâã', desc: 'ÈÅ†Á®ãËº∏Âá∫ÔºåÈõô‰∫∫ÁµÑ', cost: 3, count: 2, hp: 350, dmg: 80, speed: 0.4, range: 110, atkSpd: 50, type: 'ground', target: 'any', icon: 'üèπ', radius: 12, mass: 1.5, deployTime: 60, rarity: 'common' },
    musketeer: { id: 'musketeer', name: 'ÁÅ´ÊßçÊâã', desc: 'Ë∂ÖÈÅ†Â∞ÑÁ®ãÔºåÂñÆÈ´îÈ´òÂÇ∑', cost: 4, count: 1, hp: 600, dmg: 180, speed: 0.35, range: 140, atkSpd: 60, type: 'ground', target: 'any', icon: 'üëí', radius: 14, mass: 2.0, deployTime: 60, rarity: 'rare' },
    giant: { id: 'giant', name: 'Â∑®‰∫∫', desc: 'Âè™ÊâìÂª∫ÁØâÔºåË∂ÖÂéöËÇâÁõæ', cost: 5, count: 1, hp: 3500, dmg: 250, speed: 0.2, range: 0, atkSpd: 120, type: 'ground', target: 'building', icon: 'ü¶ç', radius: 28, mass: 30.0, deployTime: 120, rarity: 'rare' },
    prince: { id: 'prince', name: 'ÁéãÂ≠ê', desc: 'Ë°ùÈãíÈô∑Èô£ÔºåÈõôÂÄçÂÇ∑ÂÆ≥', cost: 5, count: 1, hp: 1600, dmg: 325, speed: 0.35, range: 0, atkSpd: 80, type: 'ground', target: 'any', icon: 'üêé', radius: 18, mass: 8.0, deployTime: 60, chargeSpeed: 0.75, chargeDmgMult: 2.0, rarity: 'epic' },
    skarmy: { id: 'skarmy', name: 'È™∑È´èËªçÂúò', desc: '‰∫∫Êµ∑Êà∞Ë°ìÔºåËÑÜÂº±È´òÂÇ∑', cost: 3, count: 5, hp: 60, dmg: 40, speed: 0.55, range: 0, atkSpd: 30, type: 'ground', target: 'any', icon: 'üíÄ', radius: 8, mass: 0.5, deployTime: 30, rarity: 'epic' },
    wizard: { id: 'wizard', name: 'Ê≥ïÂ∏´', desc: 'ÁØÑÂúçÂÇ∑ÂÆ≥ÔºåÊ∏ÖÂÖµÂà©Âô®', cost: 5, count: 1, hp: 700, dmg: 180, speed: 0.3, range: 120, atkSpd: 90, type: 'ground', target: 'any', icon: 'üßô‚Äç‚ôÇÔ∏è', aoe: 60, radius: 14, mass: 2.5, deployTime: 60, rarity: 'rare' },
    bats: { id: 'bats', name: 'ËùôËù†', desc: 'Á©∫‰∏≠Áæ§È´îÔºåÊ•µÈÄüÊîªÊìä', cost: 2, count: 4, hp: 50, dmg: 50, speed: 0.7, range: 0, atkSpd: 25, type: 'air', target: 'any', icon: 'ü¶á', radius: 8, mass: 0.5, deployTime: 30, rarity: 'common' },
    minipekka: { id: 'minipekka', name: 'Ëø∑‰Ω†ÁöÆÂç°', desc: 'ÂñÆÈ´îÁàÜÁôºÔºåÂàáÂù¶Á•ûÂô®', cost: 4, count: 1, hp: 1100, dmg: 550, speed: 0.55, range: 0, atkSpd: 95, type: 'ground', target: 'any', icon: 'ü§ñ', radius: 16, mass: 5.0, deployTime: 60, rarity: 'rare' },
    hogrider: { id: 'hogrider', name: 'ÈáéË±¨È®éÂ£´', desc: 'Âø´ÈÄüÁ™ÅÊìäÔºåÁõ¥ÊåáÂª∫ÁØâ', cost: 4, count: 1, hp: 1400, dmg: 260, speed: 0.8, range: 0, atkSpd: 70, type: 'ground', target: 'building', icon: 'üê∑', radius: 18, mass: 5.0, deployTime: 60, rarity: 'rare' },
    babydragon: { id: 'babydragon', name: 'È£õÈæçÂØ∂ÂØ∂', desc: 'Á©∫‰∏≠ÁØÑÂúçÊîªÊìäÔºåÊúâÈªûËÇâ', cost: 4, count: 1, hp: 1000, dmg: 130, speed: 0.45, range: 90, atkSpd: 80, type: 'air', target: 'any', icon: 'üê≤', aoe: 50, radius: 16, mass: 4.0, deployTime: 60, rarity: 'epic' },
    golem: { id: 'golem', name: 'ÊààÂ¥ôÁü≥‰∫∫', desc: 'Á©∂Ê•µËÇâÁõæÔºåÊ≠ª‰∫°ÁàÜÁÇ∏', cost: 8, count: 1, hp: 4500, dmg: 280, speed: 0.15, range: 0, atkSpd: 140, type: 'ground', target: 'building', icon: 'üóø', radius: 32, mass: 50.0, deployTime: 180, deathDmg: 300, rarity: 'legendary' },
    fireball: { id: 'fireball', name: 'ÁÅ´ÁêÉË°ì', desc: 'ÂçÄÂüüÊ≥ïË°ìÔºåÊìäÈÄÄÊïàÊûú', cost: 4, count: 1, hp: 0, dmg: 350, speed: 0, range: 0, atkSpd: 0, type: 'spell', target: 'any', icon: 'üî•', aoe: 110, knockback: 8, rarity: 'rare' },
    zap: { id: 'zap', name: 'ÈõªÊìäÊ≥ïË°ì', desc: '‰ΩéË≤ªÊöàÁú©ÔºåÊâìÊñ∑ÊîªÊìä', cost: 2, count: 1, hp: 0, dmg: 70, speed: 0, range: 0, atkSpd: 0, type: 'spell', target: 'any', icon: '‚ö°', aoe: 80, stun: 60, rarity: 'common' },
    barrel: { id: 'barrel', name: 'Âì•Â∏ÉÊûóÈ£õÊ°∂', desc: 'ÂÖ®ÂúñÂÅ∑Ë•≤ÔºåËêΩÂú∞ÁîüÂÖµ', cost: 3, count: 1, hp: 0, dmg: 50, speed: 0, range: 0, atkSpd: 0, type: 'spell', target: 'any', icon: 'üõ¢Ô∏è', spawnUnit: 'goblins', knockback: 0, rarity: 'epic' },
    cannon: { id: 'cannon', name: 'Âä†Ëæ≤Á†≤', desc: 'Èò≤Á¶¶Âª∫ÁØâÔºåÂ£ΩÂëΩÊúâÈôê', cost: 3, count: 1, hp: 800, dmg: 100, speed: 0, range: 120, atkSpd: 60, type: 'building', target: 'any', icon: '‚öôÔ∏è', radius: 20, mass: 100, lifeTime: 1800, deployTime: 180, rarity: 'common' },
    goblins: { id: 'goblins', name: 'Âì•Â∏ÉÊûó', cost: 2, count: 3, hp: 180, dmg: 90, speed: 0.65, range: 0, atkSpd: 35, type: 'ground', target: 'any', icon: 'üë∫', radius: 10, mass: 0.8, deployTime: 10, rarity: 'common' }
};
const ALL_CARDS = Object.keys(CARDS).filter(k => k !== 'goblins');
const RECOMMENDED_CARDS = ['knight', 'archer', 'giant', 'fireball', 'musketeer', 'minipekka'];

// --- Á≥ªÁµ±Â∑•ÂÖ∑ ---
const AudioSys = {
    ctx: null,
    init() { window.AudioContext = window.AudioContext || window.webkitAudioContext; this.ctx = new AudioContext(); },
    play(type) {
        if(!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); gain.connect(this.ctx.destination); osc.connect(gain);
        if(type==='spawn'){ osc.frequency.setValueAtTime(300,t); osc.frequency.exponentialRampToValueAtTime(50,t+.2); gain.gain.setValueAtTime(.1,t); gain.gain.exponentialRampToValueAtTime(.01,t+.2); osc.start(); osc.stop(t+.2); }
        else if(type==='attack'){ osc.type='triangle'; osc.frequency.setValueAtTime(150,t); osc.frequency.linearRampToValueAtTime(100,t+.05); gain.gain.setValueAtTime(.05,t); gain.gain.linearRampToValueAtTime(0,t+.05); osc.start(); osc.stop(t+.05); }
        else if(type==='boom'){ osc.type='sawtooth'; osc.frequency.setValueAtTime(120,t); osc.frequency.exponentialRampToValueAtTime(10,t+.4); gain.gain.setValueAtTime(.2,t); gain.gain.exponentialRampToValueAtTime(.01,t+.4); osc.start(); osc.stop(t+.4); }
        else if(type==='ui'){ osc.frequency.setValueAtTime(800,t); gain.gain.setValueAtTime(.05,t); gain.gain.exponentialRampToValueAtTime(.01,t+.1); osc.start(); osc.stop(t+.1); }
    }
};
class Vector2 { constructor(x,y){this.x=x;this.y=y;} add(v){this.x+=v.x;this.y+=v.y;return this;} sub(v){this.x-=v.x;this.y-=v.y;return this;} mult(n){this.x*=n;this.y*=n;return this;} mag(){return Math.sqrt(this.x*this.x+this.y*this.y);} normalize(){let m=this.mag();if(m>0)this.mult(1/m);return this;} dist(v){return Math.hypot(this.x-v.x,this.y-v.y);} copy(){return new Vector2(this.x,this.y);}}
class ParticlePool { constructor(){this.pool=[];this.max=200;} get(x,y,c,t,v){let p=this.pool.find(i=>!i.active); if(!p){if(this.pool.length<this.max){p=new Particle();this.pool.push(p);}else return null;} p.reset(x,y,c,t,v); return p;} updateAndDraw(ctx){this.pool.forEach(p=>{if(p.active){p.update();p.draw(ctx);}});} clear(){this.pool.forEach(p=>p.active=false);} }
class Particle { constructor(){this.active=false;this.pos=new Vector2(0,0);this.vel=new Vector2(0,0);} reset(x,y,c,t,v){this.active=true;this.pos.x=x;this.pos.y=y;this.type=t;this.color=c;this.life=1.0; if(t==='text'||t==='emote'){this.text=v;this.vel=new Vector2(0,t==='emote'?-0.8:-2.5);this.scale=t==='emote'?1:Math.min(2,0.8+v/200);}else if(t==='spawn_flash'){this.vel=new Vector2(0,0);this.size=10;}else{this.vel=new Vector2((Math.random()-0.5)*3,(Math.random()-0.5)*3);this.size=Math.random()*4+2;}} update(){this.pos.add(this.vel);this.life-=0.03;if(this.life<=0)this.active=false;if(this.type==='spawn_flash')this.size+=2;} draw(ctx){if(!this.active)return;ctx.globalAlpha=Math.max(0,this.life); if(this.type==='emote'){ctx.font="30px sans-serif";ctx.fillText(this.text,this.pos.x,this.pos.y);}else if(this.type==='spawn_flash'){ctx.fillStyle='#fff';ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.size,0,Math.PI*2);ctx.fill();}else if(this.type==='text'){ctx.fillStyle=this.color;ctx.font="bold 16px sans-serif";ctx.fillText(this.text,this.pos.x,this.pos.y);}else{ctx.fillStyle=this.color;ctx.beginPath();ctx.arc(this.pos.x,this.pos.y,this.size,0,Math.PI*2);ctx.fill();} ctx.globalAlpha=1;} }

// --- ÈÅäÊà≤Ê†∏ÂøÉÈ°ûÂà• ---
class Entity {
    constructor(x, y, team, radius) {
        this.pos = new Vector2(x, y); this.team = team; this.radius = radius;
        this.dead = false; this.hp = 100; this.maxHp = 100; this.flash = 0;
        this.knockbackVel = new Vector2(0,0); this.stunTimer = 0; this.shakeX=0; this.shakeY=0;
    }
    takeDamage(amt) {
        this.hp -= amt; this.flash = 5;
        this.shakeX = (Math.random()-0.5)*6; this.shakeY = (Math.random()-0.5)*6;
        Game.particles.get(this.pos.x, this.pos.y-30, '#fff', 'text', Math.floor(amt));
        if(this.hp <= 0) { this.dead = true; if(this.deathDmg) Game.projectiles.push(new Projectile(this.pos, new Vector2(0,0), this.deathDmg, 100, 'fireball', this.team)); }
    }
    drawHp(ctx, offset) {
        if(this.hp < this.maxHp && this.hp > 0) {
            const w = 32; ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(this.pos.x-w/2-2, this.pos.y-this.radius-offset-2, w+4, 8);
            ctx.fillStyle = this.team==='player'?CONFIG.COLORS.P_MAIN:CONFIG.COLORS.E_MAIN; ctx.fillRect(this.pos.x-w/2, this.pos.y-this.radius-offset, w*(this.hp/this.maxHp), 4);
        }
    }
    update(){ this.shakeX*=0.8; this.shakeY*=0.8; if(this.flash>0) this.flash--; if(this.stunTimer>0) this.stunTimer--; if(this.knockbackVel.mag()>0.1){this.pos.add(this.knockbackVel);this.knockbackVel.mult(0.85);} }
}

class Unit extends Entity {
    constructor(x, y, team, key) {
        const d = CARDS[key]; super(x, y, team, d.radius);
        this.key = key; this.hp = d.hp; this.maxHp = d.hp; this.dmg = d.dmg; this.speed = d.speed;
        this.range = d.range; this.atkSpd = d.atkSpd; this.type = d.type; this.targetType = d.target;
        this.mass = d.mass; this.deployTimer = d.deployTime; this.maxDeploy = d.deployTime;
        this.atkTimer = 0; this.facing = 1; this.frame = Math.random()*100;
    }
    update() {
        super.update(); if(this.dead || this.deployTimer>0 || this.stunTimer>0) { if(this.deployTimer>0) this.deployTimer--; return; }
        this.frame++; if(this.atkTimer>0) this.atkTimer--;
        
        const target = this.findTarget();
        if(target) {
            const dist = this.pos.dist(target.pos);
            if(dist <= this.range + this.radius + target.radius) {
                if(this.atkTimer <= 0) {
                    if(this.range > 50) Game.projectiles.push(new Projectile(this.pos, target, this.dmg, 0, this.key, this.team));
                    else { target.takeDamage(this.dmg); AudioSys.play('attack'); }
                    this.atkTimer = this.atkSpd;
                }
            } else if(this.speed > 0) this.moveTowards(target.pos);
        } else if(this.speed > 0) {
            const goalY = this.team==='player' ? -100 : Game.height+100;
            this.moveTowards(new Vector2(this.pos.x, goalY));
        }
        if(this.speed>0) this.collide();
    }
    moveTowards(dest) {
        let target = dest.copy();
        const riverY = Game.height * CONFIG.RIVER_OFFSET;
        if(this.type!=='air' && ((this.pos.y<riverY && dest.y>riverY) || (this.pos.y>riverY && dest.y<riverY)) && Math.abs(this.pos.y-riverY)>20) {
            const bL = Game.width*0.25, bR = Game.width*0.75;
            const bridgeX = Math.abs(this.pos.x-bL)<Math.abs(this.pos.x-bR) ? bL : bR;
            target = new Vector2(bridgeX + (this.pos.x%30-15), riverY);
        }
        const dir = target.sub(this.pos).normalize();
        this.pos.add(dir.mult(this.speed));
        if(dir.x>0.1) this.facing=1; else if(dir.x<-0.1) this.facing=-1;
    }
    collide() {
        if(this.type==='air') return;
        const force = new Vector2(0,0);
        Game.units.forEach(u => {
            if(u===this || u.dead || u.deployTimer>0 || u.type==='air') return;
            const d = this.pos.dist(u.pos), minD = this.radius+u.radius;
            if(d<minD) force.add(this.pos.copy().sub(u.pos).normalize().mult((minD-d)*0.15 * Math.min(2, u.mass/this.mass)));
        });
        this.pos.add(force);
        this.pos.x = Math.max(15, Math.min(Game.width-15, this.pos.x));
    }
    findTarget() {
        const list = this.targetType==='building' ? [...Game.towers, ...Game.units.filter(u=>u.type==='building')] : [...Game.towers, ...Game.units];
        let best = null, minD = Infinity;
        list.forEach(t => {
            if(t.team!==this.team && !t.dead && t.deployTimer<=0) {
                if(t instanceof Tower && t.isKing && !t.active && t.team!==this.team) return;
                const d = this.pos.dist(t.pos); if(d<minD) { minD=d; best=t; }
            }
        });
        if(!best && this.targetType!=='building') best = Game.towers.find(t=>t.team!==this.team && t.isKing);
        return best;
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.pos.x + this.shakeX, this.pos.y + this.shakeY); if(this.type==='air') ctx.translate(0,-40);
        if(this.deployTimer>0) {
            ctx.globalAlpha=0.6; ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.arc(0,0,this.radius,0,Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(0,0); ctx.fillStyle='#fff'; ctx.arc(0,0,this.radius,-Math.PI/2,-Math.PI/2+(Math.PI*2*(1-this.deployTimer/this.maxDeploy))); ctx.fill(); ctx.restore(); return;
        }
        if(this.flash>0) ctx.filter='brightness(2)';
        ctx.scale(this.facing, 1);
        ctx.fillStyle = this.team==='player' ? CONFIG.COLORS.P_MAIN : CONFIG.COLORS.E_MAIN;
        // Áπ™ÂúñÈÇÑÂéü(Á∞°ÂåñÂúìÂΩ¢+icon)
        ctx.beginPath(); ctx.arc(0,-5,this.radius,0,Math.PI*2); ctx.fill();
        ctx.font="20px serif"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(CARDS[this.key].icon,0,-5);
        ctx.restore(); this.drawHp(ctx, this.radius+(this.type==='air'?45:5));
    }
}

class Tower extends Entity {
    constructor(x, y, team, isKing) {
        super(x, y, team, isKing?32:24);
        this.isKing = isKing; this.active = !isKing;
        this.maxHp = isKing?4000:2500; this.hp = this.maxHp; this.range = 160; this.atkTimer = 0;
        this.name = ""; 
    }
    update() {
        super.update(); if(this.dead) return;
        if(this.isKing && !this.active) { if(this.hp<this.maxHp || Game.towers.some(t=>t.team===this.team && !t.isKing && t.dead)) this.active=true; }
        if(!this.active) return;
        if(this.atkTimer>0) this.atkTimer--;
        let target = null, minD = this.range;
        Game.units.forEach(u => { if(u.team!==this.team && !u.dead && u.deployTimer<=0) { const d=this.pos.dist(u.pos); if(d<minD){minD=d; target=u;} } });
        if(target && this.atkTimer<=0) {
            Game.projectiles.push(new Projectile(new Vector2(this.pos.x, this.pos.y-(this.isKing?40:30)), target, this.isKing?120:90, 0, 'arrow', this.team));
            this.atkTimer = 45;
        }
    }
    draw(ctx) {
        const x = this.pos.x + this.shakeX, y = this.pos.y + this.shakeY;
        ctx.fillStyle = '#95a5a6'; ctx.fillRect(x-this.radius, y-10, this.radius*2, 20);
        ctx.fillStyle = this.team==='player'?CONFIG.COLORS.P_MAIN:CONFIG.COLORS.E_MAIN; ctx.fillRect(x-15, y-40, 30, 30);
        if(this.isKing) {
            ctx.font = "30px serif"; ctx.textAlign="center"; ctx.fillText(this.active?"üëë":"üí§", x, y-45);
        }
        this.drawHp(ctx, this.isKing?65:45);
    }
}

class Projectile {
    constructor(pos, target, dmg, aoe, key, team) {
        this.pos = pos.copy(); this.startPos = pos.copy(); this.target = target; this.dmg = dmg; this.aoe = aoe; this.key = key; this.team = team;
        this.isSpell = (key==='fireball'||key==='barrel'||key==='zap');
        this.dest = this.isSpell ? target.copy() : target.pos.copy();
        this.speed = key==='barrel'?Math.max(3,this.pos.dist(this.dest)/60) : (key==='fireball'?6:7);
        this.height = 0; this.dead = false;
    }
    update() {
        if(!this.isSpell && !this.target.dead) this.dest = this.target.pos.copy();
        const dToT = this.pos.dist(this.dest), travelled = this.pos.dist(this.startPos);
        if(this.isSpell) this.height = Math.sin((travelled/(travelled+dToT))*Math.PI) * 120;
        
        if(dToT < this.speed+5 && this.height<15) {
            this.dead = true;
            if(this.key==='barrel') { for(let i=0;i<3;i++) Game.units.push(new Unit(this.dest.x+(i-1)*10, this.dest.y, this.team, 'goblins')); AudioSys.play('boom'); return; }
            let targets = (this.aoe>0 || this.isSpell) ? [...Game.units, ...Game.towers].filter(e=>e.pos.dist(this.dest)<=this.aoe) : [this.target];
            if(this.aoe>0) AudioSys.play(this.key==='zap'?'zap':'boom');
            targets.forEach(t => { if(t.team!==this.team){ t.takeDamage(this.dmg); if(this.key==='fireball') t.knockbackVel.add(t.pos.copy().sub(this.pos).normalize().mult(8)); } });
        } else {
            this.pos.add(this.dest.copy().sub(this.pos).normalize().mult(this.speed));
        }
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.pos.x, this.pos.y-this.height);
        ctx.fillStyle = this.team==='player'?CONFIG.COLORS.P_MAIN:CONFIG.COLORS.E_MAIN;
        if(this.key==='fireball') ctx.fillStyle='#e74c3c';
        ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

let socket;
const Game = {
    canvas: null, ctx: null, width: 0, height: 0, running: false,
    units: [], towers: [], projectiles: [], particles: new ParticlePool(),
    elixir: 5, userLoadout: ['knight', 'archer', 'giant', 'fireball', 'musketeer', 'bats'],
    deck: [], hand: [], nextCard: null, selectedIdx: null, draggingIdx: null, dragPos: {x:0,y:0}, isDragging: false,
    roomID: null, playerName: "Áé©ÂÆ∂1",

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize(); window.addEventListener('resize', () => this.resize());
        
        const c = document.getElementById('game-container');
        c.onpointerdown = e => this.pDown(e);
        c.onpointermove = e => this.pMove(e);
        c.onpointerup = e => this.pUp(e);
        
        AudioSys.init();
        this.renderElixir();
    },
    resize(){ const w=document.getElementById('canvas-wrapper'); this.width=w.clientWidth; this.height=w.clientHeight; this.canvas.width=this.width; this.canvas.height=this.height; },

    // --- ÈÄ£Á∑öËàáÂåπÈÖç ---
    findMatch() {
        this.playerName = document.getElementById('nickname').value.trim() || "Áé©ÂÆ∂1";
        const btn = document.getElementById('find-btn');
        const status = document.getElementById('match-status-txt');
        const spinner = document.getElementById('wait-spinner');

        btn.disabled = true;
        status.innerText = "ÈÄ£Á∑ö‰∏≠...";
        spinner.style.display = 'block';

        if(!socket) socket = io();
        
        // Render ÂñöÈÜíÊèêÁ§∫
        let connected = false;
        setTimeout(() => { if(!connected) status.innerText = "‰º∫ÊúçÂô®ÂñöÈÜí‰∏≠..."; }, 3000);

        socket.on('connect', () => {
            connected = true;
            status.innerText = "Ê≠£Âú®Â∞ãÊâæÂ∞çÊâã...";
            socket.emit('find_match');
        });

        socket.on('game_start', (data) => {
            this.roomID = data.roomID;
            status.innerText = "ÈÖçÂ∞çÊàêÂäüÔºÅ";
            this.startGame();
            // Á´ãÂç≥ÁôºÈÄÅÂêçÂ≠ó
            socket.emit('action', { roomID: this.roomID, type: 'name_sync', name: this.playerName });
        });

        socket.on('remote_action', (data) => {
            if(data.type === 'spawn') {
                const realX = (1 - data.nx) * this.width;
                const realY = (1 - data.ny) * this.height;
                this.spawn(data.card, realX, realY, 'enemy');
            } else if (data.type === 'name_sync') {
                // Êî∂Âà∞ÂêçÂ≠óÔºåÊõ¥Êñ∞ UI
                const nameDisplay = document.getElementById('enemy-name-txt');
                if(nameDisplay) nameDisplay.innerText = data.name;
                const t = this.towers.find(t => t.team === 'enemy' && t.isKing);
                if(t) t.name = data.name;
            } else if (data.type === 'emote') {
                this.showEmote(data.val, 'enemy');
            }
        });
        
        socket.on('opponent_left', () => this.endGame(true));
    },

    startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('end-screen').classList.add('hidden');
        this.reset();
        this.running = true;
        
        const t = this.towers.find(t => t.team === 'player' && t.isKing);
        if(t) t.name = this.playerName;

        let timeLeft = CONFIG.GAME_TIME;
        this.timerInt = setInterval(() => {
            if(!this.running) return;
            timeLeft--;
            const m = Math.floor(timeLeft/60), s = timeLeft%60;
            document.getElementById('timer').innerText = `0${m}:${s<10?'0'+s:s}`;
            if(timeLeft===CONFIG.DOUBLE_ELIXIR_THRESHOLD) {
                document.getElementById('elixir-mode-txt').className='show';
                setTimeout(()=>document.getElementById('elixir-mode-txt').className='',2000);
            }
            if(timeLeft<=0) this.endGame(null);
        }, 1000);
        this.loop();
    },

    reset() {
        this.units=[]; this.projectiles=[]; this.particles.clear(); this.elixir=5;
        this.deck = [...this.userLoadout, ...this.userLoadout].sort(()=>Math.random()-0.5);
        this.hand = []; for(let i=0;i<4;i++) this.hand.push(this.deck.pop());
        this.nextCard = this.deck.pop();
        
        const pY=this.height-140, eY=140, bL=this.width*0.25, bR=this.width*0.75;
        this.towers = [
            new Tower(bL, pY, 'player', false), new Tower(bR, pY, 'player', false), new Tower(this.width/2, pY+50, 'player', true),
            new Tower(bL, eY, 'enemy', false), new Tower(bR, eY, 'enemy', false), new Tower(this.width/2, eY-50, 'enemy', true)
        ];
        document.getElementById('enemy-name-txt').innerText = "Á≠âÂæÖÂ∞çÊâã...";
        this.renderDeck();
    },

    // --- Êìç‰Ωú ---
    pDown(e) {
        if(!this.running) return;
        const t = e.target.closest('.card');
        const rect = this.canvas.getBoundingClientRect();
        if(t && t.dataset.index) {
            const idx = parseInt(t.dataset.index);
            if(this.elixir >= CARDS[this.hand[idx]].cost) {
                this.draggingIdx = idx; this.selectedIdx = idx; this.isDragging = true;
                this.dragPos = {x: e.clientX-rect.left, y: e.clientY-rect.top};
                this.renderDeck();
            }
        } else if (this.selectedIdx !== null && !this.isDragging) {
            const y = e.clientY - rect.top;
            if(y < this.height) this.trySpawn(this.selectedIdx, e.clientX-rect.left, y);
        }
    },
    pMove(e) { 
        const rect = this.canvas.getBoundingClientRect();
        if(this.isDragging) this.dragPos = {x: e.clientX-rect.left, y: e.clientY-rect.top};
    },
    pUp(e) {
        if(this.isDragging) {
            const rect = this.canvas.getBoundingClientRect();
            if(e.clientY-rect.top < this.height-100) this.trySpawn(this.draggingIdx, this.dragPos.x, this.dragPos.y);
            this.isDragging=false; this.draggingIdx=null; this.selectedIdx=null; this.renderDeck();
        }
    },

    trySpawn(idx, x, y) {
        const key = this.hand[idx];
        const d = CARDS[key];
        const riverY = this.height * CONFIG.RIVER_OFFSET;
        if(d.type!=='spell' && y < riverY) { this.msg("ÂÉÖËÉΩÈÉ®ÁΩ≤ÊñºÂ∑±ÊñπÂçÄÂüü"); return; }
        
        this.elixir -= d.cost;
        this.spawn(key, x, y, 'player');
        
        if(socket) {
            socket.emit('action', {
                roomID: this.roomID, type: 'spawn', card: key,
                nx: x / this.width, ny: y / this.height
            });
        }
        this.hand[idx] = this.nextCard;
        this.nextCard = this.deck.length>0 ? this.deck.pop() : this.userLoadout[Math.floor(Math.random()*6)];
        this.renderDeck();
    },

    spawn(key, x, y, team) {
        const d = CARDS[key];
        AudioSys.play('spawn');
        if(d.type==='spell') {
            Game.projectiles.push(new Projectile(new Vector2(this.width/2, team==='player'?this.height:0), new Vector2(x,y), d.dmg, d.aoe, key, team));
        } else {
            const count = d.count || 1;
            for(let i=0; i<count; i++) {
                let ox = (i-(count-1)/2)*15; 
                this.units.push(new Unit(x+ox, y, team, key));
            }
            Game.particles.get(x, y, '#fff', 'spawn_flash', 0);
        }
    },

    triggerEmote(emoji) {
        this.showEmote(emoji, 'player');
        if(socket) socket.emit('action', { roomID: this.roomID, type: 'emote', val: emoji });
        document.getElementById('emote-menu').classList.remove('open');
    },
    showEmote(emoji, team) {
        const t = this.towers.find(t => t.team === team && t.isKing);
        if(t) Game.particles.get(t.pos.x, t.pos.y-60, null, 'emote', emoji);
    },

    loop() {
        if(!this.running) return;
        requestAnimationFrame(() => this.loop());
        
        this.elixir = Math.min(CONFIG.ELIXIR_MAX, this.elixir + CONFIG.ELIXIR_RATE_BASE);
        this.renderElixir();

        [...this.units, ...this.towers, ...this.projectiles].forEach(e => e.update());
        this.particles.updateAndDraw(this.ctx);
        this.units = this.units.filter(u=>!u.dead); this.towers = this.towers.filter(t=>!t.dead); this.projectiles = this.projectiles.filter(p=>!p.dead);
        
        const pK = this.towers.find(t=>t.team==='player'&&t.isKing);
        const eK = this.towers.find(t=>t.team==='enemy'&&t.isKing);
        if(!pK) this.endGame(false); else if(!eK) this.endGame(true);
        
        this.draw();
    },

    draw() {
        this.ctx.clearRect(0,0,this.width,this.height);
        // ÂéüÂßãÂú∞ÂúñÁπ™Ë£ΩÈÇèËºØ (ËçâÂú∞+Ê†ºÁ¥ã+Ê∞¥+Ê©ã)
        this.ctx.fillStyle = CONFIG.COLORS.GRASS; this.ctx.fillRect(0,0,this.width,this.height);
        this.ctx.fillStyle = 'rgba(0,0,0,0.03)'; const size = 40; // Ê†ºÁ¥ã
        for(let x=0; x<this.width; x+=size) for(let y=0; y<this.height; y+=size) if((x/size + y/size)%2===0) this.ctx.fillRect(x, y, size, size);
        
        const ry = this.height*CONFIG.RIVER_OFFSET;
        this.ctx.fillStyle = CONFIG.COLORS.WATER; this.ctx.fillRect(0, ry-30, this.width, 60);
        
        const drawBridge = (bx) => {
            this.ctx.fillStyle = '#636e72'; this.ctx.fillRect(bx-30, ry-35, 60, 70);
            this.ctx.fillStyle = '#b2bec3'; this.ctx.fillRect(bx-26, ry-35, 52, 70);
            this.ctx.fillStyle = '#dfe6e9'; for(let i=0; i<6; i++) this.ctx.fillRect(bx-24, ry-30 + i*11, 48, 4);
        };
        drawBridge(this.width*0.25); drawBridge(this.width*0.75);

        // Áπ™Ë£ΩÂØ¶È´î
        this.units.forEach(u=>u.drawShadow(this.ctx)); this.towers.forEach(t=>t.drawShadow(this.ctx));
        [...this.towers, ...this.units].sort((a,b)=>a.pos.y-b.pos.y).forEach(e=>e.draw(this.ctx));
        this.projectiles.forEach(p=>p.draw(this.ctx));
        
        if(this.isDragging) {
            const d = CARDS[this.hand[this.draggingIdx]];
            const valid = d.type==='spell' || this.dragPos.y > this.height*CONFIG.RIVER_OFFSET;
            this.ctx.save(); this.ctx.translate(this.dragPos.x, this.dragPos.y);
            this.ctx.globalAlpha=0.5; this.ctx.fillStyle=valid?'#3498db':'#e74c3c';
            this.ctx.beginPath(); this.ctx.arc(0,0,d.radius||d.aoe||20,0,Math.PI*2); this.ctx.fill();
            this.ctx.font="30px serif"; this.ctx.textAlign="center"; this.ctx.fillText(d.icon,0,10);
            this.ctx.restore();
        }
    },

    renderElixir() {
        document.getElementById('elixir-fill').style.width = (this.elixir*10)+'%';
        document.getElementById('elixir-badge').innerText = Math.floor(this.elixir);
        document.querySelectorAll('#hand-cards .card').forEach((el,i)=>{
            if(this.hand[i]) el.classList.toggle('disabled', this.elixir < CARDS[this.hand[i]].cost);
        });
    },
    renderDeck() {
        document.getElementById('next-icon').innerText = CARDS[this.nextCard].icon;
        const h = document.getElementById('hand-cards'); h.innerHTML='';
        this.hand.forEach((k,i)=>{
            const d=CARDS[k], el=document.createElement('div');
            el.className=`card ${d.rarity}`; el.dataset.index=i;
            if(this.selectedIdx===i && !this.isDragging) el.classList.add('selected');
            if(this.draggingIdx===i) el.classList.add('dragging');
            el.innerHTML=`<div class="cost">${d.cost}</div><div class="card-inner"><div class="emoji">${d.icon}</div></div>`;
            h.appendChild(el);
        });
        this.renderElixir();
    },
    msg(t){ const m=document.getElementById('message'); m.innerText=t; m.className='show'; setTimeout(()=>m.className='',1200); },
    endGame(win){
        this.running=false; clearInterval(this.timerInt); if(socket) socket.disconnect();
        if(win===null){ const p=this.towers.filter(t=>t.team==='player').reduce((a,b)=>a+b.hp,0), e=this.towers.filter(t=>t.team==='enemy').reduce((a,b)=>a+b.hp,0); win=p>=e; }
        const t=document.getElementById('end-title'); t.innerText=win?"ÂãùÂà©":"Â§±Êïó"; t.style.color=win?"#f1c40f":"#e74c3c";
        document.getElementById('end-screen').classList.remove('hidden');
    },

    openDeckEditor(){ document.getElementById('deck-editor').classList.remove('hidden'); this.renderEditor(); },
    closeDeckEditor(){ if(this.userLoadout.length===6) document.getElementById('deck-editor').classList.add('hidden'); else alert("ÈúÄ6ÂºµÂç°"); },
    renderEditor(){
        const g=document.getElementById('editor-grid'); g.innerHTML='';
        ALL_CARDS.forEach(k=>{
            const d=CARDS[k], el=document.createElement('div');
            el.className=`editor-card card ${d.rarity} ${this.userLoadout.includes(k)?'picked':''}`;
            const rec = RECOMMENDED_CARDS.includes(k) ? `<div class="rec-tag">Êé®Ëñ¶</div>` : '';
            el.innerHTML=`${rec}<div class="cost">${d.cost}</div><div class="card-inner"><div class="emoji">${d.icon}</div></div>`;
            el.onclick=()=>{
                if(this.userLoadout.includes(k)){ if(this.userLoadout.length>1) this.userLoadout=this.userLoadout.filter(c=>c!==k); }
                else{ if(this.userLoadout.length<6) this.userLoadout.push(k); }
                document.getElementById('editor-desc').innerText = `${d.name}: ${d.desc}`;
                this.renderEditor();
            };
            g.appendChild(el);
        });
    }
};

window.onload = () => Game.init();
</script>
</body>
</html>